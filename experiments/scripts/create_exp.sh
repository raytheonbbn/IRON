#!/usr/bin/env bash
# IRON: iron_headers
#
# Distribution A
#
# Approved for Public Release, Distribution Unlimited
#
# EdgeCT (IRON) Software Contract No.: HR0011-15-C-0097
# DCOMP (GNAT)  Software Contract No.: HR0011-17-C-0050
# Copyright (c) 2015-20 Raytheon BBN Technologies Corp.
#
# This material is based upon work supported by the Defense Advanced
# Research Projects Agency under Contracts No. HR0011-15-C-0097 and
# HR0011-17-C-0050. Any opinions, findings and conclusions or
# recommendations expressed in this material are those of the author(s)
# and do not necessarily reflect the views of the Defense Advanced
# Research Project Agency.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# IRON: end


#
# This script generates the templated configuration files for an IRON
# experiment. At completion, the configuration files provide the IRON
# infrastructure over which the experiment will be run. Following the
# execution of this script, the user must edit the generated
# configuration files to configure the "what" of the experiment,
# including, the desired flows, the desired utility function
# definitions, and the desired network impairments.
#
# The script currently assumes the following:
#
#   - A full mesh topology will be generated by default
#   - All links in the topology are configured the same

# This script's name for error messages.
this="${0##*/}"

BASE_DIR=${HOME}
ENC_CONN_FILE="/tmp/enc_conn.cfg"
GRID_TOPO=0
HGRID_TOPO=0
MESH_TOPO=1
RING_TOPO=0
USER_TOPO=0
DURATION=60
DUAL_HOME=0
DELAY=10
THROTTLE=100000
BUF_SIZE=500000
ERROR_MODEL=SPER
JITTER_MODEL=None
NEWLINE="
"
NUM_INT_ENCLAVES=0

#declare -a NBR_ARRAY

#=============================================================================
# Print out usage information and exit.
usage() {
    echo ""
    echo "Description:"
    echo ""
    echo "Generate the templated configuration files for an IRON experiment."
    echo "By default, a full mesh topology is created for the experiment."
    echo "This behavior can be changed by using the '-C' or '-G' command-line"
    echo "options."
    echo ""
    echo "Usage:"
    echo "  ${this} [-B <base dir>] [-C <conn_cfg_file>] [-G <MxN>]"
    echo "    [-l <duration>] [-D] [-d <delay>] [-t <throttle>] [-b <size>]"
    echo "    [-E <error model name>] [-J <jitter model name>] [-h]"
    echo "    num_enclaves experiment_name"
    echo ""
    echo "Options:"
    echo "  -B <base dir>           The base directory for the generated"
    echo "                          experiment configuration files."
    echo "                          Default: ${BASE_DIR}"
    echo "  -C <conn_cfg_file>      Generates a topology corresponding to the"
    echo "                          user-provided enclave connectivity"
    echo "                          configuration file."
    echo "  -G <MxN>                Generate a grid topology, with M rows and"
    echo "                          N columns."
    echo "  -H <MxN>                Generate a hollow grid topology, with M"
    echo "                          rows and N columns. Any nodes not on the"
    echo "                          grid perimeter are interior nodes."
    echo "  -R <MxNx...xZ>          Generate a concentric ring topology, with"
    echo "                          M edge nodes, N nodes in the outermost "
    echo "                          ring of interior nodes, ..., to Z nodes in"
    echo "                          the innermost ring of interior nodes. The "
    echo "                          number of nodes in each ring should be an"
    echo "                          integer multiple of the number of nodes in"
    echo "                          the ring immediately within it."
    echo "  -l <duration>           The duration of the experiment, in"
    echo "                          seconds."
    echo "                          Default: ${DURATION}"
    echo "  -D                      Experiment enclaves are dual homed."
    echo "                          Default: False"
    echo "  -d <delay>              Initial link propagation delay, in ms."
    echo "                          Default: ${DELAY}"
    echo "  -t <throttle>           Initial link throttle value, in Kbps."
    echo "                          Default: ${THROTTLE}"
    echo "  -b <size>               Initial link buffer size, in bytes."
    echo "                          Default: ${BUF_SIZE}"
    echo "  -E <error model name>   Initial link error model name. One of"
    echo "                          SPER, SBER, or None."
    echo "                          Default: ${ERROR_MODEL}"
    echo "  -J <jitter model name>  Initial link jitter model name. One of"
    echo "                          GMM, DMM, or None."
    echo "                          Default: ${JITTER_MODEL}"
    echo "  -h                      Print usage information."
    echo ""

    # Exit the script with an error.
    exit 1
}

#=============================================================================
# Load the enclave connectivity map that defines the enclave
# connectivity in the experiment.
load_enclave_conn_cfg() {
    # Grab the information in the enclave connectivity configuration
    # file. Each line in this file contains the connected neighbors
    # for the i'th enclave in the configuration. The format of the
    # entries in this configuration file are as follows:
    #
    #  e_id:nbr_id_1 nbr_id_2 ... nbr_id_N
    #
    # where e_id is the identifier of the enclave and nbr_id_1,
    # nbr_id_2 ... nbr_id_N are the enclave identifiers of the
    # enclaves that the e_id enclave is connected to.
    #
    # Store this information for each enclave in an array for later use.
    while IFS= read -r LINE; do
	ENC_ID=$(echo ${LINE} | cut -d ":" -f1)
	NBR_ARRAY[${ENC_ID}]=$(echo ${LINE} | cut -d ":" -f2)
    done < ${ENC_CONN_FILE}
}

#=============================================================================
# Generate the default 'enclaves.cfg' file for the experiment. This
# will be used if the experimentation testbed environment does not
# have a node reservation system.
gen_default_enclaves_file() {
    ENCLAVES_CFG_FILE="${EXP_DIR}/enclaves.cfg"
    ENCLAVES_STR="ENCLAVES=("

    for ENC in $(seq 1 ${NUM_ENCLAVES}); do
	if [ ! ${ENC} -eq 1 ]; then
	    ENCLAVES_STR="${ENCLAVES_STR} ${ENC}"
	else
	    ENCLAVES_STR="${ENCLAVES_STR}${ENC}"
	fi
    done

    ENCLAVES_STR="${ENCLAVES_STR})"
    echo "${ENCLAVES_STR}" >> ${ENCLAVES_CFG_FILE}
}

#=============================================================================
# Copy the common configuration files.
copy_common_config_files() {
    cp ${COMMON_DIR}/*.cfg ${EXP_CFG_DIR}
}

#=============================================================================
# Generate the experiment template file.
gen_exp_template() {
    EXP_CONF_FILE="${EXP_DIR}/exp.tmpl"
    NODE_LIST_STR=""
    IRON_NODES_STR=""
    MGEN_NODES_STR=""
    LE_NODES_STR=""
    PROXY_IN_IFS_STR=""

    for ENC in $(seq 1 ${NUM_ENCLAVES}); do
	NODE_LIST_STR="${NODE_LIST_STR} \$enclave${ENC}_app1_node\$"
	NODE_LIST_STR="${NODE_LIST_STR} \$enclave${ENC}_iron_node\$"
	NODE_LIST_STR="${NODE_LIST_STR} \$enclave${ENC}_le1_node\$"
	if [ ${DUAL_HOME} -eq 1 ]; then
	    NODE_LIST_STR="${NODE_LIST_STR} \$enclave${ENC}_le2_node\$"
	fi
	IRON_NODES_STR="${IRON_NODES_STR} \$enclave${ENC}_iron_node\$"
	MGEN_NODES_STR="${MGEN_NODES_STR} \$enclave${ENC}_app1_node\$"
	LE_NODES_STR="${LE_NODES_STR} \$enclave${ENC}_le1_node\$"
	LE_NODES_STR="${LE_NODES_STR}:\$enclave${ENC}_iron_node\$"
	LE_NODES_STR="${LE_NODES_STR}:\$enclave${ENC}_iron_wan1_link\$"
	if [ ${DUAL_HOME} -eq 1 ]; then
	    LE_NODES_STR="${LE_NODES_STR} \$enclave${ENC}_le2_node\$"
	    LE_NODES_STR="${LE_NODES_STR}:\$enclave${ENC}_iron_node\$"
	    LE_NODES_STR="${LE_NODES_STR}:\$enclave${ENC}_iron_wan2_link\$"
	fi
	PROXY_IN_IFS_STR="${PROXY_IN_IFS_STR} \$enclave${ENC}_iron_node\$"
	PROXY_IN_IFS_STR="${PROXY_IN_IFS_STR}:\$enclave${ENC}_iron_lan_link\$"
    done

    # Strip out any trailing spaces from the constructed strings.
    NODE_LIST_STR=$(echo ${NODE_LIST_STR} | xargs)
    IRON_NODES_STR=$(echo ${IRON_NODES_STR} | xargs)
    MGEN_NODES_STR=$(echo ${MGEN_NODES_STR} | xargs)
    LE_NODES_STR=$(echo ${LE_NODES_STR} | xargs)
    PROXY_IN_IFS_STR=$(echo ${PROXY_IN_IFS_STR} | xargs)

    # Write the information to the exp.tmpl file.
    echo "DURATION=${DURATION}" >> ${EXP_CONF_FILE}
    echo "" >> ${EXP_CONF_FILE}
    echo "NODE_LIST=(${NODE_LIST_STR})" >> ${EXP_CONF_FILE}
    echo "IRON_NODES=(${IRON_NODES_STR})" >> ${EXP_CONF_FILE}
    echo "MGEN_NODES=(${MGEN_NODES_STR})" >> ${EXP_CONF_FILE}
    echo "LINKEM_NODES=(${LE_NODES_STR})" >> ${EXP_CONF_FILE}
    echo "PROXY_INBOUND_IFS=(${PROXY_IN_IFS_STR})" >> ${EXP_CONF_FILE}
    echo "# PCAPS=()" >> ${EXP_CONF_FILE}
    echo "# DECAP=()" >> ${EXP_CONF_FILE}
}

#=============================================================================
# Generate the AMP templated configuration files.
gen_amp_templates() {
    cp ${TEMPLATE_DIR}/amp_services.tmpl ${EXP_CFG_DIR}

    NUM_EDGE_ENCLAVES=$(echo ${NUM_ENCLAVES} - ${NUM_INT_ENCLAVES} | bc)
    for ENC in $(seq 1 ${NUM_EDGE_ENCLAVES}); do
	AMP_CONF_FILE=${EXP_CFG_DIR}/amp_enclave${ENC}.tmpl
	cp ${TEMPLATE_DIR}/amp_config.tmpl ${AMP_CONF_FILE}
    done
}

#=============================================================================
# Generate the bin map templated configuration file.
gen_bin_map_template() {
    cp ${TEMPLATE_DIR}/bin_map.tmpl ${EXP_CFG_DIR}
    BIN_MAP_CONF_FILE=${EXP_CFG_DIR}/bin_map.tmpl
    BIN_IDS=""
    BIN_MAP_STR=""

    NUM_EDGE_ENCLAVES=$(echo ${NUM_ENCLAVES} - ${NUM_INT_ENCLAVES} | bc)
    for ENC in $(seq 1 ${NUM_EDGE_ENCLAVES}); do
	BIN_ID=$(echo ${ENC} - 1 | bc)
	BIN_IDS="${BIN_IDS} ${BIN_ID}"
    done
    BIN_IDS=$(echo ${BIN_IDS} | xargs)
    BIN_IDS=$(echo ${BIN_IDS} | tr " " ",")
    BIN_MAP_STR="BinMap.BinIds                ${BIN_IDS}${NEWLINE}"

    if [ ${NUM_INT_ENCLAVES} != 0 ]
    then
	INT_BIN_IDS=""
	FIRST_INT_ENCLAVE=$(echo ${NUM_EDGE_ENCLAVES} + 1 | bc)
	for ENC in $(seq ${FIRST_INT_ENCLAVE} ${NUM_ENCLAVES}); do
	    BIN_ID=$(echo ${ENC} - 1 | bc)
	    INT_BIN_IDS="${INT_BIN_IDS} ${BIN_ID}"
	done
	INT_BIN_IDS=$(echo ${INT_BIN_IDS} | xargs)
	INT_BIN_IDS=$(echo ${INT_BIN_IDS} | tr " " ",")
	BIN_MAP_STR="${BIN_MAP_STR}BinMap.IntBinIds             ${INT_BIN_IDS}${NEWLINE}"
    fi

    for ENC in $(seq 1 ${NUM_EDGE_ENCLAVES}); do
	BIN_ID=$(echo ${ENC} - 1 | bc)
#	BIN_MAP_STR="${BIN_MAP_STR}BinMap.BinId.${BIN_ID}.IronNodeAddr"
#	BIN_MAP_STR="${BIN_MAP_STR}  \$enclave${ENC}_iron_lan_addr\$"
#	BIN_MAP_STR="${BIN_MAP_STR}${NEWLINE}"

	BIN_MAP_STR="${BIN_MAP_STR}BinMap.BinId.${BIN_ID}.HostMasks"
	BIN_MAP_STR="${BIN_MAP_STR}     \$enclave${ENC}_iron_lan_subnet/24\$"
	BIN_MAP_STR="${BIN_MAP_STR}${NEWLINE}"
    done

    echo "${BIN_MAP_STR}" >> ${BIN_MAP_CONF_FILE}
}

#=============================================================================
# Generate the BPF templated configuration files.
gen_bpf_templates() {
    BPF_STR=""

    for ENC in $(seq 1 ${NUM_ENCLAVES}); do
	BPF_CONF_FILE=${EXP_CFG_DIR}/bpf_enclave${ENC}.tmpl
	cp ${TEMPLATE_DIR}/bpf_config.tmpl ${BPF_CONF_FILE}

	NBRS=($(echo ${NBR_ARRAY[$ENC]} | tr ' ' '\n'))
	NUM_PATH_CTRLS="${#NBRS[@]}"

	BPF_STR="${NEWLINE}"

	# BinId values are zero-based.
	BPF_STR="${BPF_STR}# IRON node Bin Id.${NEWLINE}"
	BPF_STR="${BPF_STR}Bpf.BinId $(echo ${ENC} - 1 | bc)"

	BPF_STR="${BPF_STR}${NEWLINE}${NEWLINE}"
	BPF_STR="${BPF_STR}# The number of Path Controllers.${NEWLINE}"

	if [ ${DUAL_HOME} -eq 1 ]; then
	    NUM_PATH_CTRLS=$((NUM_PATH_CTRLS * 2))
	fi

	BPF_STR="${BPF_STR}Bpf.NumPathControllers"
	BPF_STR="${BPF_STR} ${NUM_PATH_CTRLS}${NEWLINE}"
	BPF_STR="${BPF_STR}${NEWLINE}"
	BPF_STR="${BPF_STR}# Path Controller configuration.${NEWLINE}"
	BPF_STR="${BPF_STR}${NEWLINE}"

	PATH_CTRL_ID=0
	for NBR in ${NBRS[*]}; do
	    BPF_STR="${BPF_STR}PathController.${PATH_CTRL_ID}.Type"
	    BPF_STR="${BPF_STR}       SliqCat${NEWLINE}"
	    ENDPTS_STR="\$enclave${ENC}_iron_wan1_addr\$->"
	    ENDPTS_STR="${ENDPTS_STR}\$enclave${NBR}_iron_wan1_addr\$"
	    BPF_STR="${BPF_STR}PathController.${PATH_CTRL_ID}.Endpoints  "
	    BPF_STR="${BPF_STR}${ENDPTS_STR}${NEWLINE}"

	    PATH_CTRL_ID=$((PATH_CTRL_ID + 1))

	    if [ ${DUAL_HOME} -eq 1 ]; then
		BPF_STR="${BPF_STR}PathController.${PATH_CTRL_ID}.Type"
		BPF_STR="${BPF_STR}       SliqCat${NEWLINE}"
		ENDPTS_STR="\$enclave${ENC}_iron_wan2_addr\$->"
		ENDPTS_STR="${ENDPTS_STR}\$enclave${NBR}_iron_wan2_addr\$"
		BPF_STR="${BPF_STR}PathController.${PATH_CTRL_ID}.Endpoints  "
		BPF_STR="${BPF_STR}${ENDPTS_STR}${NEWLINE}"
		PATH_CTRL_ID=$((PATH_CTRL_ID + 1))
	    fi
	done

	echo "${BPF_STR}" >> ${BPF_CONF_FILE}
    done
}

#=============================================================================
# Generate the link emulator templated configuration files.
gen_lem_templates() {
    # Create the lem_init.tmpl configuration template.
    LEM_INIT_CONF_FILE=${EXP_CFG_DIR}/lem_init.tmpl
    cp ${TEMPLATE_DIR}/lem_init.tmpl ${LEM_INIT_CONF_FILE}

    for ENC in $(seq 1 ${NUM_ENCLAVES}); do
	echo "" >> ${LEM_INIT_CONF_FILE}
	echo "# Enclave ${ENC} LinkEm configuration." >> ${LEM_INIT_CONF_FILE}

	NBRS=($(echo ${NBR_ARRAY[$ENC]} | tr ' ' '\n'))
	for NBR in ${NBRS[*]}; do
	    ENC_NODE_STR="-h \$enclave${ENC}_le1_node\$"
	    LEM_STR='${LEC_BIN} '"${ENC_NODE_STR} -P ${NBR}"
	    if [ ${DUAL_HOME} -eq 1 ]; then
		LEM_STR="${LEM_STR} -s \$enclave${NBR}_iron_wan1_addr\$/24"
	    else
		LEM_STR="${LEM_STR} -s \$enclave${NBR}_iron_wan1_addr\$/16"
	    fi
	    echo "${LEM_STR}" >> ${LEM_INIT_CONF_FILE}

	    LEM_STR='${LEC_BIN} '"${ENC_NODE_STR} -P ${NBR} -I 1"
	    LEM_STR="${LEM_STR} -b ${BUF_SIZE}"
	    echo "${LEM_STR}" >> ${LEM_INIT_CONF_FILE}

	    LEM_STR='${LEC_BIN} '"${ENC_NODE_STR} -P ${NBR} -I 2"
	    LEM_STR="${LEM_STR} -b ${BUF_SIZE} -t ${THROTTLE}"
	    LEM_STR="${LEM_STR} -d ${DELAY} -E ${ERROR_MODEL}"
	    LEM_STR="${LEM_STR} -J ${JITTER_MODEL}"
	    echo "${LEM_STR}" >> ${LEM_INIT_CONF_FILE}

	    if [ ${DUAL_HOME} -eq 1 ]; then
		ENC_NODE_STR="-h \$enclave${ENC}_le2_node\$"
		LEM_STR='${LEC_BIN} '"${ENC_NODE_STR} -P ${NBR}"
		LEM_STR="${LEM_STR} -s \$enclave${NBR}_iron_wan2_addr\$/24"
		echo "${LEM_STR}" >> ${LEM_INIT_CONF_FILE}

		LEM_STR='${LEC_BIN} '"${ENC_NODE_STR} -P ${NBR} -I 1"
		LEM_STR="${LEM_STR} -b ${BUF_SIZE}"
		echo "${LEM_STR}" >> ${LEM_INIT_CONF_FILE}

		LEM_STR='${LEC_BIN} '"${ENC_NODE_STR} -P ${NBR} -I 2"
		LEM_STR="${LEM_STR} -b ${BUF_SIZE} -t ${THROTTLE}"
		LEM_STR="${LEM_STR} -d ${DELAY} -E ${ERROR_MODEL}"
		LEM_STR="${LEM_STR} -J ${JITTER_MODEL}"
		echo "${LEM_STR}" >> ${LEM_INIT_CONF_FILE}
	    fi
	done
    done

    # Create the lem.tmpl configuration template.
    LEM_CONF_FILE=${EXP_CFG_DIR}/lem.tmpl
    cp ${TEMPLATE_DIR}/lem.tmpl ${LEM_CONF_FILE}
}

#=============================================================================
# Generated the TCP Proxy templated configuration files.
gen_tcp_proxy_templates() {
    NUM_EDGE_ENCLAVES=$(echo ${NUM_ENCLAVES} - ${NUM_INT_ENCLAVES} | bc)
    for ENC in $(seq 1 ${NUM_EDGE_ENCLAVES}); do
	TCP_PROXY_CONF_FILE=${EXP_CFG_DIR}/tcp_proxy_enclave${ENC}.tmpl
	cp ${TEMPLATE_DIR}/tcp_proxy_config.tmpl ${TCP_PROXY_CONF_FILE}
    done
}

#=============================================================================
# Generate traffic templated configuration file.
gen_traffic_template() {
    TRAFFIC_CONF_FILE=${EXP_CFG_DIR}/traffic.tmpl
    cp ${TEMPLATE_DIR}/traffic.tmpl ${TRAFFIC_CONF_FILE}
}

#=============================================================================
# Generated the UDP Proxy templated configuration files.
gen_udp_proxy_templates() {
    NUM_EDGE_ENCLAVES=$(echo ${NUM_ENCLAVES} - ${NUM_INT_ENCLAVES} | bc)
    for ENC in $(seq 1 ${NUM_EDGE_ENCLAVES}); do
	UDP_PROXY_CONF_FILE=${EXP_CFG_DIR}/udp_proxy_enclave${ENC}.tmpl
	cp ${TEMPLATE_DIR}/udp_proxy_config.tmpl ${UDP_PROXY_CONF_FILE}
    done
}

# Process the command line options.
while getopts B:C:G:H:R:l:Dd:t:b:E:J:h option; do
    case $option in
	B)
	    BASE_DIR=${OPTARG};;
	C)
	    if [[ ${GRID_TOPO} == 1 || ${HGRID_TOPO} == 1 || \
			${RING_TOPO} == 1 ]] ; then
		echo "Error: -C, -G, -H, and -R options are mutually" \
		     "exclusive. (1)"
		usage
	    fi
	    GRID_TOPO=0
	    HGRID_TOPO=0
	    MESH_TOPO=0
	    RING_TOPO=0
	    USER_TOPO=1
	    ENC_CONN_FILE=${OPTARG};;
	G)
	    if [[ ${HGRID_TOPO} == 1 || ${RING_TOPO} == 1 || \
			${USER_TOPO} == 1 ]] ; then
		echo "Error: -C, -G, -H, and -R options are mutually" \
		     "exclusive. (2)"
		usage
	    fi
	    GRID_TOPO=1
	    HGRID_TOPO=0
	    MESH_TOPO=0
	    RING_TOPO=0
	    USER_TOPO=0
	    GEN_CONN_CFG_ARG="-G ${OPTARG}";;
	H)
	    if [[ ${GRID_TOPO} == 1 || ${RING_TOPO} == 1 || \
			${USER_TOPO} == 1 ]] ; then
		echo "Error: -C, -G, H, and -R options are mutually" \
		     "exclusive. (3)"
		usage
	    fi
	    GRID_TOPO=0
	    HGRID_TOPO=1
	    MESH_TOPO=0
	    RING_TOPO=0
	    USER_TOPO=0
	    GEN_CONN_CFG_ARG="-H ${OPTARG}";;
	R)
	    if [[ ${GRID_TOPO} == 1 || ${HGRID_TOPO} == 1 || \
			${USER_TOPO} == 1 ]] ; then
		echo "Error: -C, -G, -H, and -R options are mutually" \
		     "exclusive. (4)"
		usage
	    fi
	    GRID_TOPO=0
	    HGRID_TOPO=0
	    MESH_TOPO=0
	    RING_TOPO=1
	    USER_TOPO=0
	    GEN_CONN_CFG_ARG="-R ${OPTARG}";;
	l)
	    DURATION=${OPTARG};;
	D)
	    DUAL_HOME=1;;
	d)
	    DELAY=${OPTARG};;
	t)
	    THROTTLE=${OPTARG};;
	b)
	    BUF_SIZE=${OPTARG};;
	E)
	    ERROR_MODEL=${OPTARG};;
	J)
	    JITTER_MODEL=${OPTARG};;
	h|?)
	    usage;;
    esac
done

# Grab the command line arguments.
shift $((${OPTIND} - 1))

# Make sure we have the correct number of command line arguments.
if [ "$#" -ne 2 ]; then
    echo ""
    echo "Missing required command line argument(s). Aborting..."
    echo ""
    usage
fi

NUM_ENCLAVES=$1
EXP_NAME=$2

# Create the directories for the experiment that is being created.
EXP_DIR="${BASE_DIR}/${EXP_NAME}"
if [ -e ${EXP_DIR} ]; then
    echo ""
    echo "Directory ${EXP_DIR} already exists. Aborting..."

    # Exit the script with an error.
    exit 1
fi

mkdir -p ${EXP_DIR}

EXP_CFG_DIR="${EXP_DIR}/cfgs"
if [ -e ${EXP_CFG_DIR} ]; then
    echo ""
    echo "Directory ${EXP_CFG_DIR}/cfgs already exists. Aborting..."

    # Exit the script with an error.
    exit 1
fi

mkdir -p ${EXP_CFG_DIR}

if [ ${MESH_TOPO} == 1 ]; then
    GEN_CONN_CFG_ARG="-M ${NUM_ENCLAVES}"
    ENC_CONN_FILE="${EXP_CFG_DIR}/enc_conn.cfg"
fi

if [[ ${GRID_TOPO} == 1 || ${HGRID_TOPO} == 1 || ${RING_TOPO} == 1 ]]; then
    ENC_CONN_FILE="${EXP_CFG_DIR}/enc_conn.cfg"
fi

# Find the fully qualified path to this executing script.
MY_DIR=$(CDPATH= cd -- "$(dirname -- "$0")" && pwd)

TEMPLATE_DIR="${MY_DIR}/../templates"
COMMON_DIR="${MY_DIR}/../common"

# Generate the enclave connectivity configuration file, if necessary.
if [[ ${GRID_TOPO} == 1 || ${HGRID_TOPO} == 1 || \
	    ${MESH_TOPO} == 1 || ${RING_TOPO} == 1 ]]; then
    NENC=$(./generate_enc_conn_cfg.py ${GEN_CONN_CFG_ARG} -o ${ENC_CONN_FILE})
    nNodes=(${NENC})
    NUM_ENCLAVES=${nNodes[0]}
    NUM_INT_ENCLAVES=${nNodes[1]}
fi

# Generate the experiment configuration files.
load_enclave_conn_cfg
gen_exp_template
gen_amp_templates
gen_bin_map_template
gen_bpf_templates
gen_lem_templates
gen_tcp_proxy_templates
gen_traffic_template
gen_udp_proxy_templates
copy_common_config_files
gen_default_enclaves_file

# Exit the script successfully.
exit 0
