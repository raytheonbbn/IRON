<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>IRON: iron::PacketQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IRON
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classiron_1_1PacketQueue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classiron_1_1PacketQueue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iron::PacketQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="packet__queue_8h_source.html">packet_queue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for iron::PacketQueue:</div>
<div class="dyncontent">
<div class="center"><img src="classiron_1_1PacketQueue__inherit__graph.png" border="0" usemap="#iron_1_1PacketQueue_inherit__map" alt="Inheritance graph"/></div>
<map name="iron_1_1PacketQueue_inherit__map" id="iron_1_1PacketQueue_inherit__map">
<area shape="rect" id="node2" href="classiron_1_1Queue.html" title="iron::Queue" alt="" coords="26,5,115,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for iron::PacketQueue:</div>
<div class="dyncontent">
<div class="center"><img src="classiron_1_1PacketQueue__coll__graph.png" border="0" usemap="#iron_1_1PacketQueue_coll__map" alt="Collaboration graph"/></div>
<map name="iron_1_1PacketQueue_coll__map" id="iron_1_1PacketQueue_coll__map">
<area shape="rect" id="node2" href="classiron_1_1Queue.html" title="iron::Queue" alt="" coords="26,95,115,121"/>
<area shape="rect" id="node3" href="classiron_1_1PacketPool.html" title="iron::PacketPool" alt="" coords="11,5,130,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a16061413077906780c6ea50bf1455faf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a16061413077906780c6ea50bf1455faf">PacketQueue</a> (<a class="el" href="classiron_1_1PacketPool.html">iron::PacketPool</a> &amp;packet_pool, bool ordered=false)</td></tr>
<tr class="separator:a16061413077906780c6ea50bf1455faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493089ee8685c5148a2e08d0a2397925"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a493089ee8685c5148a2e08d0a2397925">PacketQueue</a> (<a class="el" href="classiron_1_1PacketPool.html">iron::PacketPool</a> &amp;packet_pool, uint32_t sl, <a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> drop, bool ordered=false)</td></tr>
<tr class="separator:a493089ee8685c5148a2e08d0a2397925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdecb717d868aa6b3b4bd714e7c3d795"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdecb717d868aa6b3b4bd714e7c3d795"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#acdecb717d868aa6b3b4bd714e7c3d795">~PacketQueue</a> ()</td></tr>
<tr class="memdesc:acdecb717d868aa6b3b4bd714e7c3d795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:acdecb717d868aa6b3b4bd714e7c3d795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd46af0ebeb86e8ed76894f19e4c488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a0fd46af0ebeb86e8ed76894f19e4c488">PrepareQueueIterator</a> ()</td></tr>
<tr class="memdesc:a0fd46af0ebeb86e8ed76894f19e4c488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare an iterator to the queue, starting from the back.  <a href="#a0fd46af0ebeb86e8ed76894f19e4c488">More...</a><br /></td></tr>
<tr class="separator:a0fd46af0ebeb86e8ed76894f19e4c488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326ef4711e6819b6064d0c16e6500489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a326ef4711e6819b6064d0c16e6500489">PeekNextPacket</a> (<a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a> &amp;ws)</td></tr>
<tr class="memdesc:a326ef4711e6819b6064d0c16e6500489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next packet, grab the corresponding iterator. This method advances the interval iterator_.  <a href="#a326ef4711e6819b6064d0c16e6500489">More...</a><br /></td></tr>
<tr class="separator:a326ef4711e6819b6064d0c16e6500489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c429f82bf0292272e45456c6ab4e74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a49c429f82bf0292272e45456c6ab4e74">Peek</a> ()</td></tr>
<tr class="memdesc:a49c429f82bf0292272e45456c6ab4e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the elements according to the configured policy.  <a href="#a49c429f82bf0292272e45456c6ab4e74">More...</a><br /></td></tr>
<tr class="separator:a49c429f82bf0292272e45456c6ab4e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c91383ac75f564691a958b067097f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">iron::Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a0f8c91383ac75f564691a958b067097f">PeekAtIterator</a> (<a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a> &amp;iterator)</td></tr>
<tr class="memdesc:a0f8c91383ac75f564691a958b067097f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the packet placed at the iterator. Memory ownership stays with the queue.  <a href="#a0f8c91383ac75f564691a958b067097f">More...</a><br /></td></tr>
<tr class="separator:a0f8c91383ac75f564691a958b067097f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe300bdc84738a93a1fefa21f152d626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#afe300bdc84738a93a1fefa21f152d626">GetFrontIterator</a> ()</td></tr>
<tr class="memdesc:afe300bdc84738a93a1fefa21f152d626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator at the front, intended for later dequeue.  <a href="#afe300bdc84738a93a1fefa21f152d626">More...</a><br /></td></tr>
<tr class="separator:afe300bdc84738a93a1fefa21f152d626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab251967dd1dcc5c0b8884808bd14f1bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#ab251967dd1dcc5c0b8884808bd14f1bc">GetIterator</a> (<a class="el" href="classiron_1_1Packet.html">Packet</a> *pkt)</td></tr>
<tr class="memdesc:ab251967dd1dcc5c0b8884808bd14f1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator where a given pkt is enqueued, intended for later dequeue.  <a href="#ab251967dd1dcc5c0b8884808bd14f1bc">More...</a><br /></td></tr>
<tr class="separator:ab251967dd1dcc5c0b8884808bd14f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d11bbe74c61d2c15f3969b06e1b302e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">iron::Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a2d11bbe74c61d2c15f3969b06e1b302e">DequeueAtIterator</a> ()</td></tr>
<tr class="memdesc:a2d11bbe74c61d2c15f3969b06e1b302e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue the current packet, place iterator at element following the one dequeued. Memory ownership quits the queue to go with the caller.  <a href="#a2d11bbe74c61d2c15f3969b06e1b302e">More...</a><br /></td></tr>
<tr class="separator:a2d11bbe74c61d2c15f3969b06e1b302e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f972fcbbac1e92f6907db1be56bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">iron::Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a0d1f972fcbbac1e92f6907db1be56bd4">DequeueAtIterator</a> (<a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a> &amp;iterator)</td></tr>
<tr class="memdesc:a0d1f972fcbbac1e92f6907db1be56bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue the packet placed at the iterator. Memory ownership quits the queue to go with the caller.  <a href="#a0d1f972fcbbac1e92f6907db1be56bd4">More...</a><br /></td></tr>
<tr class="separator:a0d1f972fcbbac1e92f6907db1be56bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f88c0a0879d9b562784beaf4b7e4440"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classiron_1_1Packet.html">iron::Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a5f88c0a0879d9b562784beaf4b7e4440">Dequeue</a> (uint32_t max_size_bytes=UINT32_MAX, <a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a> dst_vec=0)</td></tr>
<tr class="memdesc:a5f88c0a0879d9b562784beaf4b7e4440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue the elements according to the configured policy.  <a href="#a5f88c0a0879d9b562784beaf4b7e4440">More...</a><br /></td></tr>
<tr class="separator:a5f88c0a0879d9b562784beaf4b7e4440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb40008026e72c1fb5d126e82b2baaa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a1bb40008026e72c1fb5d126e82b2baaa">Enqueue</a> (<a class="el" href="classiron_1_1Packet.html">Packet</a> *pkt)</td></tr>
<tr class="memdesc:a1bb40008026e72c1fb5d126e82b2baaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an element into the queue.  <a href="#a1bb40008026e72c1fb5d126e82b2baaa">More...</a><br /></td></tr>
<tr class="separator:a1bb40008026e72c1fb5d126e82b2baaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d87bd4cf7e849f2e2ac421005195984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a3d87bd4cf7e849f2e2ac421005195984">SetQueueLimits</a> (uint32_t sl)</td></tr>
<tr class="memdesc:a3d87bd4cf7e849f2e2ac421005195984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the queue's size limit.  <a href="#a3d87bd4cf7e849f2e2ac421005195984">More...</a><br /></td></tr>
<tr class="separator:a3d87bd4cf7e849f2e2ac421005195984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4873f6f12076873a35a5bb0e524cf7d"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#af4873f6f12076873a35a5bb0e524cf7d">DropPacket</a> (uint32_t max_size_bytes=UINT32_MAX, <a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a> dst_vec=0)</td></tr>
<tr class="memdesc:af4873f6f12076873a35a5bb0e524cf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the packet from the queue.  <a href="#af4873f6f12076873a35a5bb0e524cf7d">More...</a><br /></td></tr>
<tr class="separator:af4873f6f12076873a35a5bb0e524cf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91aa9479d6b8bb4bdbc0db80be1cd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a0b91aa9479d6b8bb4bdbc0db80be1cd4">Purge</a> ()</td></tr>
<tr class="memdesc:a0b91aa9479d6b8bb4bdbc0db80be1cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the queue by dropping all of the packets.  <a href="#a0b91aa9479d6b8bb4bdbc0db80be1cd4">More...</a><br /></td></tr>
<tr class="separator:a0b91aa9479d6b8bb4bdbc0db80be1cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac274fce0ce73f85d63c9eff6e5be2fdb"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#ac274fce0ce73f85d63c9eff6e5be2fdb">GetCount</a> () const </td></tr>
<tr class="memdesc:ac274fce0ce73f85d63c9eff6e5be2fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the total number of packets in the queue.  <a href="#ac274fce0ce73f85d63c9eff6e5be2fdb">More...</a><br /></td></tr>
<tr class="separator:ac274fce0ce73f85d63c9eff6e5be2fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfc55ac65511a6176550ef86333a809"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a5cfc55ac65511a6176550ef86333a809">GetTotalDequeueSize</a> ()</td></tr>
<tr class="memdesc:a5cfc55ac65511a6176550ef86333a809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum of bytes available for the next dequeue.  <a href="#a5cfc55ac65511a6176550ef86333a809">More...</a><br /></td></tr>
<tr class="separator:a5cfc55ac65511a6176550ef86333a809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2fee03d875a888b122421ae6ce944a"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a1b2fee03d875a888b122421ae6ce944a">GetTotalDequeueSize</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin_idx)</td></tr>
<tr class="memdesc:a1b2fee03d875a888b122421ae6ce944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented for this <a class="el" href="classiron_1_1Queue.html">Queue</a> subclass.  <a href="#a1b2fee03d875a888b122421ae6ce944a">More...</a><br /></td></tr>
<tr class="separator:a1b2fee03d875a888b122421ae6ce944a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944a539208c8e00fe1258841c74c1181"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a944a539208c8e00fe1258841c74c1181">GetNextDequeueSize</a> ()</td></tr>
<tr class="memdesc:a944a539208c8e00fe1258841c74c1181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the next packet to be dequeued in bytes.  <a href="#a944a539208c8e00fe1258841c74c1181">More...</a><br /></td></tr>
<tr class="separator:a944a539208c8e00fe1258841c74c1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d97ae56e2e1afc42289eb520c00b53"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a13d97ae56e2e1afc42289eb520c00b53">GetNextDequeueSize</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin_idx)</td></tr>
<tr class="memdesc:a13d97ae56e2e1afc42289eb520c00b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented for this <a class="el" href="classiron_1_1Queue.html">Queue</a> subclass.  <a href="#a13d97ae56e2e1afc42289eb520c00b53">More...</a><br /></td></tr>
<tr class="separator:a13d97ae56e2e1afc42289eb520c00b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dba9a7d4a6e6661d46b671d466b66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a76dba9a7d4a6e6661d46b671d466b66b">set_drop_policy</a> (<a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> pol)</td></tr>
<tr class="memdesc:a76dba9a7d4a6e6661d46b671d466b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the drop policy associated with the queue.  <a href="#a76dba9a7d4a6e6661d46b671d466b66b">More...</a><br /></td></tr>
<tr class="separator:a76dba9a7d4a6e6661d46b671d466b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ecdc292eba6e1a6d19b7cf4ef60a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a50ecdc292eba6e1a6d19b7cf4ef60a2d">drop_policy</a> () const </td></tr>
<tr class="memdesc:a50ecdc292eba6e1a6d19b7cf4ef60a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor function to get the drop policy currently configured in the queue.  <a href="#a50ecdc292eba6e1a6d19b7cf4ef60a2d">More...</a><br /></td></tr>
<tr class="separator:a50ecdc292eba6e1a6d19b7cf4ef60a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbed6c9699ec2eec609e4d7b767f4e3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#abbed6c9699ec2eec609e4d7b767f4e3e">IsOrdered</a> () const </td></tr>
<tr class="memdesc:abbed6c9699ec2eec609e4d7b767f4e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a packet queue is ordered.  <a href="#abbed6c9699ec2eec609e4d7b767f4e3e">More...</a><br /></td></tr>
<tr class="separator:abbed6c9699ec2eec609e4d7b767f4e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590db067132c27d57cab1d2c7c25ed25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a590db067132c27d57cab1d2c7c25ed25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a590db067132c27d57cab1d2c7c25ed25">Print</a> ()</td></tr>
<tr class="memdesc:a590db067132c27d57cab1d2c7c25ed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a quick summary of the queue and its iterators. <br /></td></tr>
<tr class="separator:a590db067132c27d57cab1d2c7c25ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0041c650dae4ebe7110daeceedcd7789"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html#a0041c650dae4ebe7110daeceedcd7789">ToString</a> ()</td></tr>
<tr class="memdesc:a0041c650dae4ebe7110daeceedcd7789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string summarizing the queue depth.  <a href="#a0041c650dae4ebe7110daeceedcd7789">More...</a><br /></td></tr>
<tr class="separator:a0041c650dae4ebe7110daeceedcd7789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classiron_1_1Queue"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classiron_1_1Queue')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classiron_1_1Queue.html">iron::Queue</a></td></tr>
<tr class="memitem:aba562e0c99b183dcb19d2cec5a46bc6b inherit pub_methods_classiron_1_1Queue"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Queue.html#aba562e0c99b183dcb19d2cec5a46bc6b">Queue</a> (<a class="el" href="classiron_1_1PacketPool.html">PacketPool</a> &amp;packet_pool)</td></tr>
<tr class="separator:aba562e0c99b183dcb19d2cec5a46bc6b inherit pub_methods_classiron_1_1Queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1fae6ad9a1d7f9f8fa793114455018 inherit pub_methods_classiron_1_1Queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b1fae6ad9a1d7f9f8fa793114455018"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Queue.html#a8b1fae6ad9a1d7f9f8fa793114455018">~Queue</a> ()</td></tr>
<tr class="memdesc:a8b1fae6ad9a1d7f9f8fa793114455018 inherit pub_methods_classiron_1_1Queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8b1fae6ad9a1d7f9f8fa793114455018 inherit pub_methods_classiron_1_1Queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf12e680532a8b9a7119580ed286f48b inherit pub_methods_classiron_1_1Queue"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Queue.html#adf12e680532a8b9a7119580ed286f48b">GetSize</a> () const </td></tr>
<tr class="memdesc:adf12e680532a8b9a7119580ed286f48b inherit pub_methods_classiron_1_1Queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the total size of the queue in bytes.  <a href="#adf12e680532a8b9a7119580ed286f48b">More...</a><br /></td></tr>
<tr class="separator:adf12e680532a8b9a7119580ed286f48b inherit pub_methods_classiron_1_1Queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classiron_1_1Queue"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classiron_1_1Queue')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classiron_1_1Queue.html">iron::Queue</a></td></tr>
<tr class="memitem:aa44bd6ff197f8c93965eceec312fcbeb inherit pro_attribs_classiron_1_1Queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa44bd6ff197f8c93965eceec312fcbeb"></a>
<a class="el" href="classiron_1_1PacketPool.html">PacketPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Queue.html#aa44bd6ff197f8c93965eceec312fcbeb">packet_pool_</a></td></tr>
<tr class="memdesc:aa44bd6ff197f8c93965eceec312fcbeb inherit pro_attribs_classiron_1_1Queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool containing packets to use. <br /></td></tr>
<tr class="separator:aa44bd6ff197f8c93965eceec312fcbeb inherit pro_attribs_classiron_1_1Queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bebfdd7a87cc610ab9fe343329af20 inherit pro_attribs_classiron_1_1Queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57bebfdd7a87cc610ab9fe343329af20"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Queue.html#a57bebfdd7a87cc610ab9fe343329af20">queue_size_</a></td></tr>
<tr class="memdesc:a57bebfdd7a87cc610ab9fe343329af20 inherit pro_attribs_classiron_1_1Queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes currently in the queue. <br /></td></tr>
<tr class="separator:a57bebfdd7a87cc610ab9fe343329af20 inherit pro_attribs_classiron_1_1Queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A configurable queue that will store received packet objects as <a class="el" href="classiron_1_1Packet.html">Packet</a> pointers. It operates based on specified dequeueing and drop policies.</p>
<p>The queue owns the objects when they are queued up. However, once dequeued, the ownership is passed to the calling object.</p>
<p>The queue has a configurable size limit. This value will dictate when enqueues succeed or fail. </p>

<p>Definition at line <a class="el" href="packet__queue_8h_source.html#l00088">88</a> of file <a class="el" href="packet__queue_8h_source.html">packet_queue.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a16061413077906780c6ea50bf1455faf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iron::PacketQueue::PacketQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiron_1_1PacketPool.html">iron::PacketPool</a> &amp;&#160;</td>
          <td class="paramname"><em>packet_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>/brief Constructor.</p>
<p>Uses the default dequeue and drop policies.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_pool</td><td>Pool containing packet to use. </td></tr>
    <tr><td class="paramname">ordered</td><td>True if ordered queue, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00062">62</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a493089ee8685c5148a2e08d0a2397925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iron::PacketQueue::PacketQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiron_1_1PacketPool.html">iron::PacketPool</a> &amp;&#160;</td>
          <td class="paramname"><em>packet_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a>&#160;</td>
          <td class="paramname"><em>drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>/brief Constructor that will initialize the queue threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_pool</td><td>Pool containing packet to use. </td></tr>
    <tr><td class="paramname">sl</td><td>The queue's size limit in number of packets. </td></tr>
    <tr><td class="paramname">drop</td><td>The drop policy for the queue. </td></tr>
    <tr><td class="paramname">ordered</td><td>True if ordered queue, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00073">73</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5f88c0a0879d9b562784beaf4b7e4440"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * iron::PacketQueue::Dequeue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_size_bytes</em> = <code>UINT32_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a>&#160;</td>
          <td class="paramname"><em>dst_vec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue the elements according to the configured policy. </p>
<p>If there is no data in the queue or if the next packet cannot be returned without exceeding max_size, this returns NULL. If a packet is dequeued, the caller takes ownership of the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_size_bytes</td><td>The maximum size packet to be returned. </td></tr>
    <tr><td class="paramname">dst_vec</td><td>Destinations to dequeue for. Must be 0 for this subclass.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the packet being dequeued or NULL if there are no packets to dequeue or if the next packet exceeds the specified max size. </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#a23dcf0ee052532dd125c2285bd2ed687">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00234">234</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2d11bbe74c61d2c15f3969b06e1b302e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">iron::Packet</a> * iron::PacketQueue::DequeueAtIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue the current packet, place iterator at element following the one dequeued. Memory ownership quits the queue to go with the caller. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the dequeued packet, NULL if nothing found. </dd></dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00302">302</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0d1f972fcbbac1e92f6907db1be56bd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">iron::Packet</a> * iron::PacketQueue::DequeueAtIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a> &amp;&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue the packet placed at the iterator. Memory ownership quits the queue to go with the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>The iterator from where to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the dequeued packet, NULL if nothing found. </dd></dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00308">308</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a50ecdc292eba6e1a6d19b7cf4ef60a2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> iron::PacketQueue::drop_policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor function to get the drop policy currently configured in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The drop policy of the queue </dd></dl>

<p>Definition at line <a class="el" href="packet__queue_8h_source.html#l00350">350</a> of file <a class="el" href="packet__queue_8h_source.html">packet_queue.h</a>.</p>

</div>
</div>
<a class="anchor" id="af4873f6f12076873a35a5bb0e524cf7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t iron::PacketQueue::DropPacket </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_size_bytes</em> = <code>UINT32_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a>&#160;</td>
          <td class="paramname"><em>dst_vec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop the packet from the queue. </p>
<p>The packet selected to be dropped is determined by the drop policy configured with the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_size_bytes</td><td>The maximum size to be dropped. Ignored for this <a class="el" href="classiron_1_1Queue.html">Queue</a> type. </td></tr>
    <tr><td class="paramname">dst_vec</td><td>Destinations to drop for. Must be 0 for this subclass.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes dropped (may be 0). </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#a38c1203e0e1147e5dee68273e8f40ad1">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8h_source.html#l00285">285</a> of file <a class="el" href="packet__queue_8h_source.html">packet_queue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1bb40008026e72c1fb5d126e82b2baaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PacketQueue::Enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue an element into the queue. </p>
<p>This places the elements at the tail end of the queue. Once an object is enqueued, the queue takes ownership of the memory.</p>
<p>If the queue is already full when this method is called, then an existing packet in the queue is attempted to be dropped based on the current drop policy. Any dropped packet is silently deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>Pointer to the packet to be enqueued. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the enqueue operation succeeded and the queue </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#ade763fcdc36d0425f9bb3903d85c51be">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00365">365</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac274fce0ce73f85d63c9eff6e5be2fdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t iron::PacketQueue::GetCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to return the total number of packets in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of packets in the queue. </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#a55d04c7df34c2312cd21377e4da7712e">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8h_source.html#l00304">304</a> of file <a class="el" href="packet__queue_8h_source.html">packet_queue.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe300bdc84738a93a1fefa21f152d626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> PacketQueue::GetFrontIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator at the front, intended for later dequeue. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator. </dd></dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00120">120</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab251967dd1dcc5c0b8884808bd14f1bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> PacketQueue::GetIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the iterator where a given pkt is enqueued, intended for later dequeue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>The pkt for which to find an iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator, the NULL iterator if not found. </dd></dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00143">143</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a944a539208c8e00fe1258841c74c1181"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PacketQueue::GetNextDequeueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the next packet to be dequeued in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the next packet to be dequeued in bytes. </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#a016dbed622f9d49c9fa6ac8276e2ee73">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00441">441</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a13d97ae56e2e1afc42289eb520c00b53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PacketQueue::GetNextDequeueSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>bin_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not implemented for this <a class="el" href="classiron_1_1Queue.html">Queue</a> subclass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BinIndex</td><td>not used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LogF </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#a96a15b949b50de75e378b5b9a29fd80f">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00471">471</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5cfc55ac65511a6176550ef86333a809"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t iron::PacketQueue::GetTotalDequeueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum of bytes available for the next dequeue. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the max number of bytes available to be dequeued. </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#a2cb3e886d77314fe91fe922060678bee">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8h_source.html#l00312">312</a> of file <a class="el" href="packet__queue_8h_source.html">packet_queue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b2fee03d875a888b122421ae6ce944a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PacketQueue::GetTotalDequeueSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>bin_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not implemented for this <a class="el" href="classiron_1_1Queue.html">Queue</a> subclass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BinIndex</td><td>not used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LogF </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#aea75a412fb30024172958980755a6fdc">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00479">479</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abbed6c9699ec2eec609e4d7b767f4e3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::PacketQueue::IsOrdered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a packet queue is ordered. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ordered, false otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classiron_1_1Queue.html#a85faca645a87da2559f6e8d19d75e9b5">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8h_source.html#l00358">358</a> of file <a class="el" href="packet__queue_8h_source.html">packet_queue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a49c429f82bf0292272e45456c6ab4e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * PacketQueue::Peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek the elements according to the configured policy. </p>
<p>This method is non-blocking. If there is no data in the queue, then NULL is returned as the object. <a class="el" href="classiron_1_1Packet.html">Packet</a> ownership stays with the queue.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the packet being peeked or NULL if there are no packets to peek. </dd></dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00175">175</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0f8c91383ac75f564691a958b067097f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">iron::Packet</a> * iron::PacketQueue::PeekAtIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a> &amp;&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek the packet placed at the iterator. Memory ownership stays with the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>The iterator where to peek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the peeked packet, NULL if nothing found. </dd></dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00195">195</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a326ef4711e6819b6064d0c16e6500489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * PacketQueue::PeekNextPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">QueueWalkState</a> &amp;&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek at the next packet, grab the corresponding iterator. This method advances the interval iterator_. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The walk state returning the iterator corresponding to the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the peeked packet. </dd></dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00100">100</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0fd46af0ebeb86e8ed76894f19e4c488"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PacketQueue::PrepareQueueIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare an iterator to the queue, starting from the back. </p>
<p>This method MUST BE CALLED before any exploration of the queue. Sequence: PrepareQueueIterator, PeekAtIterator, SaveQueueIterator, IncrementQueueIterator, DequeueAtIterator. </p>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00094">94</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0b91aa9479d6b8bb4bdbc0db80be1cd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PacketQueue::Purge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the queue by dropping all of the packets. </p>
<p>Deletes all packets from the queue regardless of the drop policy. </p>

<p>Implements <a class="el" href="classiron_1_1Queue.html#ad8fa4e8c5aeefb3a35da8743ac919254">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="sliq__packet__queue_8cc_source.html#l00264">264</a> of file <a class="el" href="sliq__packet__queue_8cc_source.html">sliq_packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a76dba9a7d4a6e6661d46b671d466b66b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iron::PacketQueue::set_drop_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a>&#160;</td>
          <td class="paramname"><em>pol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to set the drop policy associated with the queue. </p>
<p>This can be changed dynamically after the object is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pol</td><td>The desired drop policy for the queue. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="packet__queue_8h_source.html#l00341">341</a> of file <a class="el" href="packet__queue_8h_source.html">packet_queue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d87bd4cf7e849f2e2ac421005195984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PacketQueue::SetQueueLimits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the queue's size limit. </p>
<p>If the current number of packets in the queue is larger than the specified size limit, then packets will be dropped from the queue using the configured drop policy until the new size limit is met. If the drop policy is set to NO_DROP, then a head drop policy will be used to resize the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The queue's size limit in number of packets. If zero is specified, then the default queue size limit is used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00410">410</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0041c650dae4ebe7110daeceedcd7789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string PacketQueue::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string summarizing the queue depth. </p>
<dl class="section return"><dt>Returns</dt><dd>The summary string. </dd></dl>

<p>Implements <a class="el" href="classiron_1_1Queue.html#aeda1534a79a91ccf1218b0c79da39836">iron::Queue</a>.</p>

<p>Definition at line <a class="el" href="packet__queue_8cc_source.html#l00591">591</a> of file <a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/szabele/github/IRON/iron/common/include/<a class="el" href="packet__queue_8h_source.html">packet_queue.h</a></li>
<li>/home/szabele/github/IRON/iron/sliq/src/<a class="el" href="sliq__packet__queue_8cc_source.html">sliq_packet_queue.cc</a></li>
<li>/home/szabele/github/IRON/iron/common/src/<a class="el" href="packet__queue_8cc_source.html">packet_queue.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceiron.html">iron</a></li><li class="navelem"><a class="el" href="classiron_1_1PacketQueue.html">PacketQueue</a></li>
    <li class="footer">Generated on Fri Feb 26 2021 11:31:59 for IRON by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
