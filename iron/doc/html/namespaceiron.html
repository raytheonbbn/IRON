<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>IRON: iron Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IRON
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceiron.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">iron Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> header file.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Amp.html">Amp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1ASAP.html">ASAP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> class contains the state and logic for the <a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> algorithm.  <a href="classiron_1_1ASAP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinIndexableArray.html">BinIndexableArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated Bin Indexable Array class.  <a href="classiron_1_1BinIndexableArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinIndexableArrayNc.html">BinIndexableArrayNc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated Bin Indexable Array No-Copy class.  <a href="classiron_1_1BinIndexableArrayNc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinIndexableArrayShm.html">BinIndexableArrayShm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated Bin Indexable Array Shared Memory class.  <a href="classiron_1_1BinIndexableArrayShm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinMap.html">BinMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping of identifiers to IRON nodes and multicast groups.  <a href="classiron_1_1BinMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html">BinQueueMgr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> class stores and manages the queues for a.  <a href="classiron_1_1BinQueueMgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BPDequeueAlg.html">BPDequeueAlg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the implementation for the base and latency-aware backpressure forwarding algorithms that select the next transmission opportunity. The class intends to keep as much common code between base and latency-aware algorithms.  <a href="classiron_1_1BPDequeueAlg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BpfStats.html">BpfStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classiron_1_1BpfStats.html" title="BpfStats class to extend and implement the stats class specifically for the needs of the BPF...">BpfStats</a> class to extend and implement the stats class specifically for the needs of the BPF. The base class <a class="el" href="classiron_1_1Stats.html">Stats</a> retains a modicum of methods and members (not all pure virtual) common to all stats classes, for instance the method to start and stop dumping, timer interval accessors, etc. This class was built around a singleton such that all elements of the bpf (backpressure_fwder, Sonds, CATs, etc.) may accumulate statistics and metrics into the same <a class="el" href="classiron_1_1BpfStats.html" title="BpfStats class to extend and implement the stats class specifically for the needs of the BPF...">BpfStats</a> object. The <a class="el" href="classiron_1_1BpfStats.html" title="BpfStats class to extend and implement the stats class specifically for the needs of the BPF...">BpfStats</a> class provides methods to accumulate stats into class members. It also starts a timer, which upon expiring, dumps these stats to the logs (as of creation of this class).  <a href="classiron_1_1BpfStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BPFwder.html">BPFwder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1BypassInfo.html">BypassInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that contains bypass information.  <a href="structiron_1_1BypassInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1CallbackInterface.html">CallbackInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for all callback objects.  <a href="classiron_1_1CallbackInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1CallbackNoArg.html">CallbackNoArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template for a callback having no arguments.  <a href="classiron_1_1CallbackNoArg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1CallbackOneArg.html">CallbackOneArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template for a callback having one argument.  <a href="classiron_1_1CallbackOneArg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1CallbackThreeArg.html">CallbackThreeArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template for a callback having three arguments.  <a href="classiron_1_1CallbackThreeArg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1CallbackTwoArg.html">CallbackTwoArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template for a callback having two arguments.  <a href="classiron_1_1CallbackTwoArg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1CmdEntry.html">CmdEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1ConfigInfo.html">ConfigInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1DebuggingStats.html">DebuggingStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for maintaining statistics in memory and logging during shut down.  <a href="classiron_1_1DebuggingStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1DequeuedInfo.html">DequeuedInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store information about a dequeued packet (or dequeued bytes for zombie queues)  <a href="structiron_1_1DequeuedInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1EdgeIf.html">EdgeIf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the abstract <a class="el" href="classiron_1_1VirtualEdgeIf.html" title="Abstract base class for edge interface implementations. ">VirtualEdgeIf</a> class.  <a href="classiron_1_1EdgeIf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1EdgeIfConfig.html">EdgeIfConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for edge interface configuration information.  <a href="classiron_1_1EdgeIfConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1EndpointInfo.html">EndpointInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1EWMABinQueueMgr.html">EWMABinQueueMgr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classiron_1_1Queue.html">Queue</a> manager using an exponential weighted moving average. This algorithm maintains a smoothed weighted moving average of the queue depth instead of an exact depth, thereby alleviating the need for long queues. In this case, even if there is a sudden burst of available capacity (common with very short queues), that burst will be softened instead of advertised as-is for BPF. This prevents a pattern of high-availability leading to heavy traffic leading to congestion leading to no traffic leading to high-availability. The pattern is instead broken because the sudden availability changes are not advertised immediately.  <a href="classiron_1_1EWMABinQueueMgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1FdEventInfo__s.html">FdEventInfo_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Fifo.html">Fifo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for inter-process signaling.  <a href="classiron_1_1Fifo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1FifoIF.html">FifoIF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract inter-process signaling interface.  <a href="classiron_1_1FifoIF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1FiveTuple.html">FiveTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1FlogUtility.html">FlogUtility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1FlowDefn.html">FlowDefn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1FlowFilter.html">FlowFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flow filter.  <a href="classiron_1_1FlowFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1FlowInfo.html">FlowInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to cache information about the flows from the proxies.  <a href="structiron_1_1FlowInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1FlowStats.html">FlowStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects and reports flow statistics.  <a href="classiron_1_1FlowStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1FourTuple.html">FourTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for an IPv4 four-tuple that uniquely identifies a flow.  <a href="classiron_1_1FourTuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1FTC.html">FTC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1FtInfo.html">FtInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to cache information about file transfers.  <a href="structiron_1_1FtInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1GenXplot.html">GenXplot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for adding on-the-fly to an xplot graph in progress.  <a href="classiron_1_1GenXplot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1GMU.html">GMU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1Gradient.html">Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the gradient structure used in algorithms.  <a href="structiron_1_1Gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1HashTable.html">HashTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template for a hash table.  <a href="classiron_1_1HashTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1HvyballBinQueueMgr.html">HvyballBinQueueMgr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classiron_1_1HvyballBinQueueMgr.html" title="HvyballBinQueueMgr class to implement the HvyballBinQueueMgr algorithm for latency reduction...">HvyballBinQueueMgr</a> class to implement the <a class="el" href="classiron_1_1HvyballBinQueueMgr.html" title="HvyballBinQueueMgr class to implement the HvyballBinQueueMgr algorithm for latency reduction...">HvyballBinQueueMgr</a> algorithm for latency reduction. This algorithm computes weights from the queue depths and uses these weights to inform the BPF and admission control algorithms. The main algorithm periodically updates weights such that: w_T+1 = w_T x beta + q_T+1, where w_T+1 is the weight at time T+1, beta is an update factor and q_T+1 is the depth of the queue at time T+1. Current weights (^w, "w hat") are also tracked such that: ^w_t = w_T - q_T + q_current. w_T weights are sent to neighbor BPF nodes and current weights to UDP/TCP proxy. All weights and queue depths are in bytes.  <a href="classiron_1_1HvyballBinQueueMgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1InterProcessComm.html">InterProcessComm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for inter-process communications (IPC).  <a href="classiron_1_1InterProcessComm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1KVal.html">KVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a fluid K value.  <a href="classiron_1_1KVal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1LatencyCacheShm.html">LatencyCacheShm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classiron_1_1LatencyCacheShm.html" title="LatencyCacheShm stores the latency of the quickest path to every destination using each CAT...">LatencyCacheShm</a> stores the latency of the quickest path to every destination using each CAT.  <a href="classiron_1_1LatencyCacheShm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1LatencyQueue.html">LatencyQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1List.html">List</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The templated non-ordered Linked <a class="el" href="classiron_1_1List.html" title="The templated non-ordered Linked List class. ">List</a> class.  <a href="classiron_1_1List.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Log.html">Log</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for logging messages to stdout, stderr, or a file.  <a href="classiron_1_1Log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1LogUtility.html">LogUtility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1MashTable.html">MashTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template for a Mash table.  <a href="classiron_1_1MashTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1NPLBBinQueueMgr.html">NPLBBinQueueMgr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classiron_1_1NPLBBinQueueMgr.html" title="NPLBBinQueueMgr class to implement the No Packet Left Behind algorithm for avoiding starvation...">NPLBBinQueueMgr</a> class to implement the No <a class="el" href="classiron_1_1Packet.html">Packet</a> Left Behind algorithm for avoiding starvation.  <a href="classiron_1_1NPLBBinQueueMgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1OrderedList.html">OrderedList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1OrderedMashTable.html">OrderedMashTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template for an Ordered Mash table.  <a href="classiron_1_1OrderedMashTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Packet.html">Packet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketFifo.html">PacketFifo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fifo for passing packing indices between processes.  <a href="classiron_1_1PacketFifo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketHistoryMgr.html">PacketHistoryMgr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for managing packet history vectors.  <a href="classiron_1_1PacketHistoryMgr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketPool.html">PacketPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketPoolHeap.html">PacketPoolHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the creation of a packet pool on the heap.  <a href="classiron_1_1PacketPoolHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketPoolShm.html">PacketPoolShm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the creation of a packet pool in shared memory.  <a href="classiron_1_1PacketPoolShm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketQueue.html">PacketQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PacketSet.html">PacketSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1PathController.html">PathController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for Path Controllers.  <a href="classiron_1_1PathController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1PathCtrlInfo.html">PathCtrlInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path controller information structure.  <a href="structiron_1_1PathCtrlInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1PktDstVecHeader.html">PktDstVecHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1PktHistoryHeader.html">PktHistoryHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1PktIdHeader.html">PktIdHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1PktLatencyHeader.html">PktLatencyHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Queue.html">Queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1QueueDepthDynamics.html">QueueDepthDynamics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for tracking queue depth dynamics over a short time.  <a href="classiron_1_1QueueDepthDynamics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1QueueDepthOsc.html">QueueDepthOsc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for tracking the queue depth oscillation period.  <a href="classiron_1_1QueueDepthOsc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1QueueDepthOscConfig.html">QueueDepthOscConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for loading the <a class="el" href="classiron_1_1QueueDepthOsc.html" title="Class for tracking the queue depth oscillation period. ">QueueDepthOsc</a> configuration information.  <a href="structiron_1_1QueueDepthOscConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classiron_1_1QueueDepths.html" title="The QueueDepths class stores queue depth information for a set of bins. ">QueueDepths</a> class stores queue depth information for a set of bins.  <a href="classiron_1_1QueueDepths.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1QueueDepthsShmStats.html">QueueDepthsShmStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains stats about current values vs most recently written.  <a href="classiron_1_1QueueDepthsShmStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1QueueStore.html">QueueStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container class for Queues and <a class="el" href="classiron_1_1Queue.html">Queue</a> Value Management for all multicast groups and destinations and for all unicast destinations. This does not depend on the forwarding algorithm or the queue value management algorithm. Differences due to the different algorithms are encapsulated in the per group/dest BinQueueMgrs.  <a href="classiron_1_1QueueStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1RemoteControl.html">RemoteControl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1RemoteControlClient.html">RemoteControlClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1RemoteControlServer.html">RemoteControlServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for remote control communications.  <a href="classiron_1_1RemoteControlServer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1RNG.html">RNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a standalone Random Number Generator.  <a href="classiron_1_1RNG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Rrm.html">Rrm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1RunnableIf.html">RunnableIf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1ScopedLock.html">ScopedLock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1SharedMemory.html">SharedMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for inter-process shared memory.  <a href="classiron_1_1SharedMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1SharedMemoryIF.html">SharedMemoryIF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract shared memory interface.  <a href="classiron_1_1SharedMemoryIF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1SliqCat.html">SliqCat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Lightweight IPv4 QUIC (SLIQ) Capacity Adaptive Tunnel (CAT) implementation.  <a href="classiron_1_1SliqCat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Sond.html">Sond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Overlay Network Device (SOND) implementation.  <a href="classiron_1_1Sond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Stats.html">Stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1StrapUtility.html">StrapUtility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1StringUtils.html">StringUtils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1SupervisoryControl.html">SupervisoryControl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1SvcDefn.html">SvcDefn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to cache service definitions for the attached proxies.  <a href="structiron_1_1SvcDefn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Svcr.html">Svcr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Thread.html">Thread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Time.html">Time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for maintaining timer events.  <a href="classiron_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1TrapUtility.html">TrapUtility</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiron_1_1TxSolution.html">TxSolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1UtilityFn.html">UtilityFn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1VirtualEdgeIf.html">VirtualEdgeIf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for edge interface implementations.  <a href="classiron_1_1VirtualEdgeIf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1ZLR.html">ZLR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing the zombie latency reduction algorithm.  <a href="classiron_1_1ZLR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1Zombie.html">Zombie</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of static utility functions for creating zombie packets.  <a href="classiron_1_1Zombie.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1ZombieQueue.html">ZombieQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa146c3e07bb0d4d0777c5cc90c334f2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa146c3e07bb0d4d0777c5cc90c334f2b"></a>
typedef struct <a class="el" href="structiron_1_1LatencyQueue.html">iron::LatencyQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LatencyQueue</b></td></tr>
<tr class="separator:aa146c3e07bb0d4d0777c5cc90c334f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f12defd24be4c98a117d6219a14edb1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structiron_1_1DequeuedInfo.html">iron::DequeuedInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a7f12defd24be4c98a117d6219a14edb1">DequeuedInfo</a></td></tr>
<tr class="memdesc:a7f12defd24be4c98a117d6219a14edb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store information about a dequeued packet (or dequeued bytes for zombie queues)  <a href="#a7f12defd24be4c98a117d6219a14edb1">More...</a><br /></td></tr>
<tr class="separator:a7f12defd24be4c98a117d6219a14edb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0944116746b96b1d7d70e1445540a90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0944116746b96b1d7d70e1445540a90"></a>
typedef enum <a class="el" href="namespaceiron.html#aa2092cd2da5aa3db884c7bfbcf7ec90a">iron::FdEvent_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ad0944116746b96b1d7d70e1445540a90">FdEvent</a></td></tr>
<tr class="memdesc:ad0944116746b96b1d7d70e1445540a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of file descriptor events of interest. <br /></td></tr>
<tr class="separator:ad0944116746b96b1d7d70e1445540a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793d5cd02db34ad78dff98376d59727e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structiron_1_1FdEventInfo__s.html">iron::FdEventInfo_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a793d5cd02db34ad78dff98376d59727e">FdEventInfo</a></td></tr>
<tr class="separator:a793d5cd02db34ad78dff98376d59727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945f54bc51c338f82666aa7b9ace4cbb"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a945f54bc51c338f82666aa7b9ace4cbb">BinId</a></td></tr>
<tr class="separator:a945f54bc51c338f82666aa7b9ace4cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b15497a0e8d187bfc7bd2e67514da4"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a73b15497a0e8d187bfc7bd2e67514da4">McastId</a></td></tr>
<tr class="separator:a73b15497a0e8d187bfc7bd2e67514da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5f420ded2cbb0ebfaf30509e0ce1d5"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a></td></tr>
<tr class="separator:a9a5f420ded2cbb0ebfaf30509e0ce1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbb07180f64325df5439a0fcc7dae80"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a></td></tr>
<tr class="separator:aacbb07180f64325df5439a0fcc7dae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a472e39b1090e6ef51b392d351e5dea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a472e39b1090e6ef51b392d351e5dea"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a8a472e39b1090e6ef51b392d351e5dea">PktMemIndex</a></td></tr>
<tr class="memdesc:a8a472e39b1090e6ef51b392d351e5dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type stored in the array of memory indices. <br /></td></tr>
<tr class="separator:a8a472e39b1090e6ef51b392d351e5dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a967c03382713d10e12ed65243542344a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a967c03382713d10e12ed65243542344a">BroadcastIndex</a> { <b>LSA_BC_IDX</b> = 0, 
<b>NUM_BC_IDX</b> = 1
 }</td></tr>
<tr class="separator:a967c03382713d10e12ed65243542344a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad659e642b72c352bd1bd2644e2d06085"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ad659e642b72c352bd1bd2644e2d06085">CatHeaderType</a> { <br />
&#160;&#160;<b>CAT_CAPACITY_EST_PACKET</b> = 48, 
<b>CAT_PKT_DST_VEC_HEADER</b> = 52, 
<b>CAT_PKT_ID_HEADER</b> = 53, 
<b>CAT_PKT_HISTORY_HEADER</b> = 54, 
<br />
&#160;&#160;<b>CAT_PKT_LATENCY_HEADER</b> = 55
<br />
 }</td></tr>
<tr class="separator:ad659e642b72c352bd1bd2644e2d06085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2092cd2da5aa3db884c7bfbcf7ec90a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aa2092cd2da5aa3db884c7bfbcf7ec90a">FdEvent_e</a> { <a class="el" href="namespaceiron.html#aa2092cd2da5aa3db884c7bfbcf7ec90aa37330092dc64d82268d7a7644a75be55">kFdEventRead</a> = 0, 
<a class="el" href="namespaceiron.html#aa2092cd2da5aa3db884c7bfbcf7ec90aae2ef6fbecf213207f316cce83b3e5bed">kFdEventWrite</a> = 1, 
<a class="el" href="namespaceiron.html#aa2092cd2da5aa3db884c7bfbcf7ec90aa06a1bb0dd42348aa27b3f3cb38d41ea5">kFdEventReadWrite</a> = 2
 }<tr class="memdesc:aa2092cd2da5aa3db884c7bfbcf7ec90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of file descriptor events of interest.  <a href="namespaceiron.html#aa2092cd2da5aa3db884c7bfbcf7ec90a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa2092cd2da5aa3db884c7bfbcf7ec90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49dbf2efb0e78e4445fe2f51d8e490f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#af49dbf2efb0e78e4445fe2f51d8e490f">XPLOT_COLOR</a> { <br />
&#160;&#160;<b>WHITE</b> = 0, 
<b>GREEN</b> = 1, 
<b>RED</b> = 2, 
<b>BLUE</b> = 3, 
<br />
&#160;&#160;<b>YELLOW</b> = 4, 
<b>PURPLE</b> = 5, 
<b>ORANGE</b> = 6, 
<b>MAGENTA</b> = 7, 
<br />
&#160;&#160;<b>PINK</b> = 8, 
<b>NUM_COLORS</b> = 9
<br />
 }</td></tr>
<tr class="separator:af49dbf2efb0e78e4445fe2f51d8e490f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0beec9aee2fa36877b51bdc4e0399da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0beec9aee2fa36877b51bdc4e0399da"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ae0beec9aee2fa36877b51bdc4e0399da">XPLOT_MARK</a> { <br />
&#160;&#160;<b>XPLOT_X</b> = 0, 
<b>XPLOT_DOT</b> = 1, 
<b>XPLOT_BOX</b> = 2, 
<b>XPLOT_DIAMOND</b> = 3, 
<br />
&#160;&#160;<b>XPLOT_UTICK</b> = 4, 
<b>XPLOT_LTICK</b> = 5, 
<b>XPLOT_DTICK</b> = 6, 
<b>XPLOT_RTICK</b> = 7, 
<br />
&#160;&#160;<b>XPLOT_VTICK</b> = 8, 
<b>XPLOT_UARROW</b> = 9, 
<b>XPLOT_DARROW</b> = 10, 
<b>XPLOT_LARROW</b> = 11, 
<br />
&#160;&#160;<b>XPLOT_RARROW</b> = 12, 
<b>XPLOT_INVISIBLE</b> = 13
<br />
 }<tr class="memdesc:ae0beec9aee2fa36877b51bdc4e0399da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of marks that we can draw on an xplot graph. <br /></td></tr>
</td></tr>
<tr class="separator:ae0beec9aee2fa36877b51bdc4e0399da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf90469ad3a0e60e29349b07ed94613a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf90469ad3a0e60e29349b07ed94613a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aaf90469ad3a0e60e29349b07ed94613a">FlowState</a> { <br />
&#160;&#160;<b>FLOW_TRIAGED</b> = 0, 
<b>FLOW_OFF</b>, 
<b>FLOW_ON</b>, 
<b>UNREACHABLE</b>, 
<br />
&#160;&#160;<b>LOSS_TRIAGED</b>, 
<b>UNDEFINED</b>
<br />
 }<tr class="memdesc:aaf90469ad3a0e60e29349b07ed94613a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of flows, as seen by the proxies. <br /></td></tr>
</td></tr>
<tr class="separator:aaf90469ad3a0e60e29349b07ed94613a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436ed3fde66cf256f942dff35d3dd4e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a436ed3fde66cf256f942dff35d3dd4e2">EFOrdering</a> { <b>EF_ORDERING_NONE</b> = 0, 
<b>EF_ORDERING_DELIVERY_MARGIN</b>, 
<b>EF_ORDERING_TTG</b>
 }</td></tr>
<tr class="separator:a436ed3fde66cf256f942dff35d3dd4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ce939dd6d396ca6eec338d5b61f0cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aa8ce939dd6d396ca6eec338d5b61f0cc">ListOrder</a> { <b>LIST_INCREASING</b> = 0, 
<b>LIST_DECREASING</b>
 }<tr class="memdesc:aa8ce939dd6d396ca6eec338d5b61f0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The templated Ordered Linked List class.  <a href="namespaceiron.html#aa8ce939dd6d396ca6eec338d5b61f0cc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa8ce939dd6d396ca6eec338d5b61f0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0af8b0162a34b134de9726d5aeab1d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ae0af8b0162a34b134de9726d5aeab1d5">PacketType</a> { <br />
&#160;&#160;<b>QLAM_PACKET</b> = 0x10, 
<b>LSA_PACKET</b> = 0x13, 
<b>ZOMBIE_PACKET</b> = 0x15, 
<b>IPV4_PACKET</b> = 0x40, 
<br />
&#160;&#160;<b>UNKNOWN_PACKET</b> = 0
<br />
 }</td></tr>
<tr class="separator:ae0af8b0162a34b134de9726d5aeab1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec605b16a7ca62ecb893b9bcece967e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a6ec605b16a7ca62ecb893b9bcece967e">DSCPSupportEnum</a> { <b>DSCP_EF</b> = 46, 
<b>DSCP_DEFAULT</b> = 0, 
<b>DSCP_TOLERANT</b> = 1
 }</td></tr>
<tr class="separator:a6ec605b16a7ca62ecb893b9bcece967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2603a9d5ad80707c1a0aa907c23833ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> { <br />
&#160;&#160;<b>CRITICAL_LATENCY</b> = 0, 
<b>CONTROL_TRAFFIC_LATENCY</b>, 
<b>LOW_LATENCY</b>, 
<b>HIGH_LATENCY_EXP</b>, 
<br />
&#160;&#160;<b>HIGH_LATENCY_NPLB_LS</b>, 
<b>HIGH_LATENCY_ZLR_LS</b>, 
<b>NORMAL_LATENCY</b>, 
<b>HIGH_LATENCY_RCVD</b>, 
<br />
&#160;&#160;<b>HIGH_LATENCY_NPLB</b>, 
<b>HIGH_LATENCY_ZLR</b>, 
<b>NUM_LATENCY_DEF</b>, 
<b>UNSET_LATENCY</b>
<br />
 }</td></tr>
<tr class="separator:a2603a9d5ad80707c1a0aa907c23833ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba594a8c6649f79e4d75062cd27f83e1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aba594a8c6649f79e4d75062cd27f83e1">PacketRecvTimeMode</a> { <b>PACKET_NO_TIMESTAMP</b> = 0, 
<b>PACKET_NOW_TIMESTAMP</b> = 1, 
<b>PACKET_COPY_TIMESTAMP</b> = 2
 }</td></tr>
<tr class="separator:aba594a8c6649f79e4d75062cd27f83e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864a6d7827d70562024605660e233435"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a864a6d7827d70562024605660e233435">PacketOwner</a> { <br />
&#160;&#160;<b>PACKET_OWNER_NONE</b> = 0, 
<b>PACKET_OWNER_UDP_PROXY</b> = 1, 
<b>PACKET_OWNER_TCP_PROXY</b> = 2, 
<b>PACKET_OWNER_BPF</b> = 3, 
<br />
&#160;&#160;<b>NUM_PACKET_OWNERS</b> = 4
<br />
 }</td></tr>
<tr class="separator:a864a6d7827d70562024605660e233435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7decbb5442a2d1e11bba19f4d4f6640d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7decbb5442a2d1e11bba19f4d4f6640d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> { <b>HEAD</b>, 
<b>TAIL</b>, 
<b>NO_DROP</b>, 
<b>UNDEFINED_DP</b>
 }<tr class="memdesc:a7decbb5442a2d1e11bba19f4d4f6640d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of possible drop policies. <br /></td></tr>
</td></tr>
<tr class="separator:a7decbb5442a2d1e11bba19f4d4f6640d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabbafe8da3ed5c11f3791ee47cfdb1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afabbafe8da3ed5c11f3791ee47cfdb1b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>RmtCntlMsgType</b> { <br />
&#160;&#160;<b>RC_SET</b>, 
<b>RC_GET</b>, 
<b>RC_PUSH</b>, 
<b>RC_PUSHREQ</b>, 
<br />
&#160;&#160;<b>RC_PUSHSTOP</b>, 
<b>RC_SETREPLY</b>, 
<b>RC_GETREPLY</b>, 
<b>RC_PUSHERR</b>, 
<br />
&#160;&#160;<b>RC_INVALID</b>
<br />
 }</td></tr>
<tr class="separator:afabbafe8da3ed5c11f3791ee47cfdb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d56141b1f998e03703f4cbc7dde350"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50d56141b1f998e03703f4cbc7dde350"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a50d56141b1f998e03703f4cbc7dde350">ShmType</a> { <b>SHM_TYPE_CREATE</b>, 
<b>SHM_TYPE_ATTACH</b>, 
<b>SHM_TYPE_LOCAL</b>
 }<tr class="memdesc:a50d56141b1f998e03703f4cbc7dde350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of an instance's possible shared memory roles. <br /></td></tr>
</td></tr>
<tr class="separator:a50d56141b1f998e03703f4cbc7dde350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ed9b2cf637d1d168ef43237386dd7ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ed9b2cf637d1d168ef43237386dd7ad"></a>
struct <a class="el" href="structiron_1_1PktDstVecHeader.html">iron::PktDstVecHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((packed))</td></tr>
<tr class="separator:a6ed9b2cf637d1d168ef43237386dd7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdef28f35debecb99cd1740d665782e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfdef28f35debecb99cd1740d665782e"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#abfdef28f35debecb99cd1740d665782e">UNUSED</a> (kUnsetTimeToGo)</td></tr>
<tr class="memdesc:abfdef28f35debecb99cd1740d665782e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic number for unspecified TTG. <br /></td></tr>
<tr class="separator:abfdef28f35debecb99cd1740d665782e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9993ec8b5c1c767ef042d9cc47371cad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9993ec8b5c1c767ef042d9cc47371cad"></a>
const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a9993ec8b5c1c767ef042d9cc47371cad">UNUSED</a> (kUnsetOriginTs)</td></tr>
<tr class="memdesc:a9993ec8b5c1c767ef042d9cc47371cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic number for unspecified origin timestamp. <br /></td></tr>
<tr class="separator:a9993ec8b5c1c767ef042d9cc47371cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3423fc28fc4a092f890863ffd15ad82"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ab3423fc28fc4a092f890863ffd15ad82">UNUSED</a> (kStartTime)</td></tr>
<tr class="memdesc:ab3423fc28fc4a092f890863ffd15ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate system start time, to be used for drawing graphs.  <a href="#ab3423fc28fc4a092f890863ffd15ad82">More...</a><br /></td></tr>
<tr class="separator:ab3423fc28fc4a092f890863ffd15ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b92ef0dda47948922cccb8405a5de75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a6b92ef0dda47948922cccb8405a5de75">operator==</a> (const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;left, const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;right)</td></tr>
<tr class="separator:a6b92ef0dda47948922cccb8405a5de75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c67dd22e7e90c21d87ddcc686b58d20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a6c67dd22e7e90c21d87ddcc686b58d20">operator!=</a> (const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;left, const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;right)</td></tr>
<tr class="separator:a6c67dd22e7e90c21d87ddcc686b58d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512351be6487eac026aa652686e96f50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a512351be6487eac026aa652686e96f50">operator&lt;</a> (const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;left, const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;right)</td></tr>
<tr class="separator:a512351be6487eac026aa652686e96f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953e7491ab2e9e21869aa644cf6dbb54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a953e7491ab2e9e21869aa644cf6dbb54">operator&gt;</a> (const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;left, const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;right)</td></tr>
<tr class="separator:a953e7491ab2e9e21869aa644cf6dbb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075849869ad27d8abe749a78d1c22466"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a075849869ad27d8abe749a78d1c22466">operator&lt;=</a> (const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;left, const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;right)</td></tr>
<tr class="separator:a075849869ad27d8abe749a78d1c22466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc71c51535171077c90ff3684da62a83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#afc71c51535171077c90ff3684da62a83">operator&gt;=</a> (const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;left, const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;right)</td></tr>
<tr class="separator:afc71c51535171077c90ff3684da62a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb76ace5528e8c690857a8a84c261e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aceb76ace5528e8c690857a8a84c261e9">operator==</a> (const <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> &amp;left, const <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> &amp;right)</td></tr>
<tr class="separator:aceb76ace5528e8c690857a8a84c261e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c4ffd219e83622dcd2402691827da2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ac4c4ffd219e83622dcd2402691827da2">operator!=</a> (const <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> &amp;left, const <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> &amp;right)</td></tr>
<tr class="separator:ac4c4ffd219e83622dcd2402691827da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a23d6a706ca42336223eaf2d947a3dcf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23d6a706ca42336223eaf2d947a3dcf3"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a23d6a706ca42336223eaf2d947a3dcf3">EFOrdering_Name</a> [] = {&quot;None&quot;, &quot;Delivery Margin&quot;, &quot;TTG&quot;}</td></tr>
<tr class="memdesc:a23d6a706ca42336223eaf2d947a3dcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">String name of the EF Ordering enum. <br /></td></tr>
<tr class="separator:a23d6a706ca42336223eaf2d947a3dcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a16d9b87f0c894eb0050b9588041ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1a16d9b87f0c894eb0050b9588041ce"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aa1a16d9b87f0c894eb0050b9588041ce">kPktDstVecHdrSize</a> = sizeof(struct <a class="el" href="structiron_1_1PktDstVecHeader.html">PktDstVecHeader</a>)</td></tr>
<tr class="memdesc:aa1a16d9b87f0c894eb0050b9588041ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the CAT packet destination vector header in bytes. <br /></td></tr>
<tr class="separator:aa1a16d9b87f0c894eb0050b9588041ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852168be6f0ea48c9bd89cbcbed90869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a852168be6f0ea48c9bd89cbcbed90869"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a852168be6f0ea48c9bd89cbcbed90869">kPktIdHdrSize</a> = sizeof(struct <a class="el" href="structiron_1_1PktIdHeader.html">PktIdHeader</a>)</td></tr>
<tr class="memdesc:a852168be6f0ea48c9bd89cbcbed90869"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the CAT packet ID header in bytes. <br /></td></tr>
<tr class="separator:a852168be6f0ea48c9bd89cbcbed90869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c76e9733b218ab14d35caf768c68de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5c76e9733b218ab14d35caf768c68de"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ac5c76e9733b218ab14d35caf768c68de">kPktHistHdrSize</a> = sizeof(struct <a class="el" href="structiron_1_1PktHistoryHeader.html">PktHistoryHeader</a>)</td></tr>
<tr class="memdesc:ac5c76e9733b218ab14d35caf768c68de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the CAT packet history header in bytes. <br /></td></tr>
<tr class="separator:ac5c76e9733b218ab14d35caf768c68de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90cc1857964b5e3839fedcc9802555"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c90cc1857964b5e3839fedcc9802555"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a4c90cc1857964b5e3839fedcc9802555">kPktLatHdrSize</a> = sizeof(struct <a class="el" href="structiron_1_1PktLatencyHeader.html">PktLatencyHeader</a>)</td></tr>
<tr class="memdesc:a4c90cc1857964b5e3839fedcc9802555"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the CAT packet latency header in bytes. <br /></td></tr>
<tr class="separator:a4c90cc1857964b5e3839fedcc9802555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6071ab534f81f0514931854a3337f4f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6071ab534f81f0514931854a3337f4f2"></a>
class <a class="el" href="classiron_1_1PathController.html">iron::PathController</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b></td></tr>
<tr class="separator:a6071ab534f81f0514931854a3337f4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ec6d537874ea6b901d5dde694d09f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ec6d537874ea6b901d5dde694d09f5"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a52ec6d537874ea6b901d5dde694d09f5">kDstVecSizeBits</a> = sizeof(<a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">iron::DstVec</a>) * 8</td></tr>
<tr class="memdesc:a52ec6d537874ea6b901d5dde694d09f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the DstVec, in bits. <br /></td></tr>
<tr class="separator:a52ec6d537874ea6b901d5dde694d09f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b0ca85efa5c3ce1fa41b4f9e7757b5"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a84b0ca85efa5c3ce1fa41b4f9e7757b5">kDstVecBitsUsed</a> = 24</td></tr>
<tr class="separator:a84b0ca85efa5c3ce1fa41b4f9e7757b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2865719ab2ac5f7ba7c7060f3129a96e"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a2865719ab2ac5f7ba7c7060f3129a96e">kMaxNumDsts</a> = <a class="el" href="namespaceiron.html#a84b0ca85efa5c3ce1fa41b4f9e7757b5">kDstVecBitsUsed</a></td></tr>
<tr class="separator:a2865719ab2ac5f7ba7c7060f3129a96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4905c835ec1940025a80ef542368380d"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a4905c835ec1940025a80ef542368380d">kMaxNumIntNodes</a> = 24</td></tr>
<tr class="separator:a4905c835ec1940025a80ef542368380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ed348b625af16e3ac441c28f97e060"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aa6ed348b625af16e3ac441c28f97e060">kMaxNumMcastGroups</a> = 16</td></tr>
<tr class="separator:aa6ed348b625af16e3ac441c28f97e060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f40b192e653f3a599664181613641d9"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a4f40b192e653f3a599664181613641d9">kMaxUcastBinId</a> = <a class="el" href="namespaceiron.html#a84b0ca85efa5c3ce1fa41b4f9e7757b5">kDstVecBitsUsed</a> - 1</td></tr>
<tr class="separator:a4f40b192e653f3a599664181613641d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0b6aa164ff1fdbdea2a60966b109f0"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a0c0b6aa164ff1fdbdea2a60966b109f0">kMaxBinId</a> = UINT8_MAX - 1</td></tr>
<tr class="separator:a0c0b6aa164ff1fdbdea2a60966b109f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaeffd5619a163e97928d8407f7f33db"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#afaeffd5619a163e97928d8407f7f33db">kMaxMcastId</a> = UINT32_MAX</td></tr>
<tr class="separator:afaeffd5619a163e97928d8407f7f33db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde28fef17bee0895c0b83f7cb32c66b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abde28fef17bee0895c0b83f7cb32c66b"></a>
const <a class="el" href="namespaceiron.html#a945f54bc51c338f82666aa7b9ace4cbb">BinId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#abde28fef17bee0895c0b83f7cb32c66b">kInvalidBinId</a> = UINT8_MAX</td></tr>
<tr class="memdesc:abde28fef17bee0895c0b83f7cb32c66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The BinId value that represents an invalid value. <br /></td></tr>
<tr class="separator:abde28fef17bee0895c0b83f7cb32c66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a019cc9ea4134bf1c66ecb1c120ec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15a019cc9ea4134bf1c66ecb1c120ec5"></a>
const <a class="el" href="namespaceiron.html#a73b15497a0e8d187bfc7bd2e67514da4">McastId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a15a019cc9ea4134bf1c66ecb1c120ec5">kInvalidMcastId</a> = 0</td></tr>
<tr class="memdesc:a15a019cc9ea4134bf1c66ecb1c120ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The McastId value that represents an invalid value. <br /></td></tr>
<tr class="separator:a15a019cc9ea4134bf1c66ecb1c120ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424baa1ad52ac7364f972597389fe18a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a424baa1ad52ac7364f972597389fe18a"></a>
const <a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a424baa1ad52ac7364f972597389fe18a">kInvalidBinIndex</a> = UINT16_MAX</td></tr>
<tr class="memdesc:a424baa1ad52ac7364f972597389fe18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The BinIndex value that represents an invalid value. <br /></td></tr>
<tr class="separator:a424baa1ad52ac7364f972597389fe18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56361a28fa63e59c8b3fc34476bf27f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56361a28fa63e59c8b3fc34476bf27f8"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a56361a28fa63e59c8b3fc34476bf27f8">kDefaultK</a> = 1e12</td></tr>
<tr class="memdesc:a56361a28fa63e59c8b3fc34476bf27f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default queue normalizer. <br /></td></tr>
<tr class="separator:a56361a28fa63e59c8b3fc34476bf27f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c983140cf3f28e3ff2278a0d7a68d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1c983140cf3f28e3ff2278a0d7a68d5"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ae1c983140cf3f28e3ff2278a0d7a68d5">kMaxPathCtrls</a> = 32</td></tr>
<tr class="memdesc:ae1c983140cf3f28e3ff2278a0d7a68d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of path controllers supported. <br /></td></tr>
<tr class="separator:ae1c983140cf3f28e3ff2278a0d7a68d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dc5150369a6f9520f8248c3d1d1bef"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ab7dc5150369a6f9520f8248c3d1d1bef">kDirectAccessQueueDepths</a> = false</td></tr>
<tr class="separator:ab7dc5150369a6f9520f8248c3d1d1bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236ac77671872cd6df8826f104487512"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a236ac77671872cd6df8826f104487512"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultPacketHistory</b> = true</td></tr>
<tr class="separator:a236ac77671872cd6df8826f104487512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eef059300c71b397dd7c21b28df225d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eef059300c71b397dd7c21b28df225d"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultPacketTrace</b> = true</td></tr>
<tr class="separator:a6eef059300c71b397dd7c21b28df225d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb428fbfd90f01af8e4654f54d18a74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcb428fbfd90f01af8e4654f54d18a74"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#afcb428fbfd90f01af8e4654f54d18a74">kDefaultTtgTracking</a> = true</td></tr>
<tr class="memdesc:afcb428fbfd90f01af8e4654f54d18a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default flag for whether to track per-packet time-to-go. <br /></td></tr>
<tr class="separator:afcb428fbfd90f01af8e4654f54d18a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cb1d9caf0626b3e2e7f25ef176efaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71cb1d9caf0626b3e2e7f25ef176efaa"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a71cb1d9caf0626b3e2e7f25ef176efaa">kDefaultLinkStateLatency</a> = true</td></tr>
<tr class="memdesc:a71cb1d9caf0626b3e2e7f25ef176efaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default flag for whether to do LSA-based latency collection. <br /></td></tr>
<tr class="separator:a71cb1d9caf0626b3e2e7f25ef176efaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51a47f77e1305a6cc4813c5db8a19f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac51a47f77e1305a6cc4813c5db8a19f7"></a>
const key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ac51a47f77e1305a6cc4813c5db8a19f7">kDefaultWeightSemKey</a> = 101</td></tr>
<tr class="memdesc:ac51a47f77e1305a6cc4813c5db8a19f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default semaphore key for queue depth weights in shared memory. <br /></td></tr>
<tr class="separator:ac51a47f77e1305a6cc4813c5db8a19f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09a16151772242bc7c4a162d2d992de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab09a16151772242bc7c4a162d2d992de"></a>
const key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ab09a16151772242bc7c4a162d2d992de">kPacketPoolSemKey</a> = 103</td></tr>
<tr class="memdesc:ab09a16151772242bc7c4a162d2d992de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The semaphore key for the packet pool segment in shared memory. <br /></td></tr>
<tr class="separator:ab09a16151772242bc7c4a162d2d992de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a02c0f043427c8cfa61bc4cb6ce0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a266a02c0f043427c8cfa61bc4cb6ce0e"></a>
const key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a266a02c0f043427c8cfa61bc4cb6ce0e">kLatencyCacheSemKey</a> = 105</td></tr>
<tr class="memdesc:a266a02c0f043427c8cfa61bc4cb6ce0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The semaphore key for the latency cache segment in shared memory. <br /></td></tr>
<tr class="separator:a266a02c0f043427c8cfa61bc4cb6ce0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34321a163836fb3fc9d9802f2d0a9c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af34321a163836fb3fc9d9802f2d0a9c0"></a>
const key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#af34321a163836fb3fc9d9802f2d0a9c0">kDefaultBinMapSemKey</a> = 107</td></tr>
<tr class="memdesc:af34321a163836fb3fc9d9802f2d0a9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The semaphore key for the bin map segment in shared memory. <br /></td></tr>
<tr class="separator:af34321a163836fb3fc9d9802f2d0a9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a67419d4782fb9923cea6ed9fe47230"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a67419d4782fb9923cea6ed9fe47230"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a0a67419d4782fb9923cea6ed9fe47230">kDefaultBpfMinBurstUsec</a> = 2000</td></tr>
<tr class="memdesc:a0a67419d4782fb9923cea6ed9fe47230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default for the minimum time window between admission control timers. <br /></td></tr>
<tr class="separator:a0a67419d4782fb9923cea6ed9fe47230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade80949fce5b2f0c833340b1ed9312b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade80949fce5b2f0c833340b1ed9312b6"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ade80949fce5b2f0c833340b1ed9312b6">kMaxPacketSizeBytes</a> = 2048</td></tr>
<tr class="memdesc:ade80949fce5b2f0c833340b1ed9312b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of the <a class="el" href="classiron_1_1Packet.html">Packet</a> buffer. <br /></td></tr>
<tr class="separator:ade80949fce5b2f0c833340b1ed9312b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059be7aef7493c603b62c58c116f59e9"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a059be7aef7493c603b62c58c116f59e9">kDefaultPacketStartBytes</a> = 32</td></tr>
<tr class="separator:a059be7aef7493c603b62c58c116f59e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd19dbdab75bfd729cae10eb0a5061"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02fd19dbdab75bfd729cae10eb0a5061"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a02fd19dbdab75bfd729cae10eb0a5061">kPacketIdSizeBits</a> = 20</td></tr>
<tr class="memdesc:a02fd19dbdab75bfd729cae10eb0a5061"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits to represent the packet id. <br /></td></tr>
<tr class="separator:a02fd19dbdab75bfd729cae10eb0a5061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55bab641c63397341d1191585edbd40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae55bab641c63397341d1191585edbd40"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>kMaxPacketId</b> = (1 &lt;&lt; <a class="el" href="namespaceiron.html#a02fd19dbdab75bfd729cae10eb0a5061">kPacketIdSizeBits</a>) - 1</td></tr>
<tr class="separator:ae55bab641c63397341d1191585edbd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a59509d908c680d1c4a0ecd781c451"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4a59509d908c680d1c4a0ecd781c451"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aa4a59509d908c680d1c4a0ecd781c451">kDefaultMultiDeq</a> = true</td></tr>
<tr class="memdesc:aa4a59509d908c680d1c4a0ecd781c451"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default setting to perform multiple dequeues. <br /></td></tr>
<tr class="separator:aa4a59509d908c680d1c4a0ecd781c451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5611f4f6e2996d8a35588bb28f86832"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5611f4f6e2996d8a35588bb28f86832"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ad5611f4f6e2996d8a35588bb28f86832">kDefaultBpfXmitQueueThreshBytes</a> = 6000</td></tr>
<tr class="memdesc:ad5611f4f6e2996d8a35588bb28f86832"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default xmit queue threshold for the BPF. <br /></td></tr>
<tr class="separator:ad5611f4f6e2996d8a35588bb28f86832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626528ffc27f4a3cf5dbc1394676352b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a626528ffc27f4a3cf5dbc1394676352b"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a626528ffc27f4a3cf5dbc1394676352b">kDefaultDropExpired</a> = false</td></tr>
<tr class="memdesc:a626528ffc27f4a3cf5dbc1394676352b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop expired packets rather than turn them into Zombies. <br /></td></tr>
<tr class="separator:a626528ffc27f4a3cf5dbc1394676352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f26138a5e61d42d6715ae67fd69088"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a60f26138a5e61d42d6715ae67fd69088">kDefaultZombieCompression</a> = false</td></tr>
<tr class="separator:a60f26138a5e61d42d6715ae67fd69088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904350cc5e832bbeb69884eea8eb9ac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a904350cc5e832bbeb69884eea8eb9ac3"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a904350cc5e832bbeb69884eea8eb9ac3">kDefaultUseAntiStarvationZombies</a> = true</td></tr>
<tr class="memdesc:a904350cc5e832bbeb69884eea8eb9ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for whether to use anti-starvation zombies as opposed to NPLB. <br /></td></tr>
<tr class="separator:a904350cc5e832bbeb69884eea8eb9ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829c4a817a146d1f6be4d5f2e6e0bc6d"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a829c4a817a146d1f6be4d5f2e6e0bc6d">kVxlanTunnelDstPort</a> = 8472</td></tr>
<tr class="memdesc:a829c4a817a146d1f6be4d5f2e6e0bc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UDP destination port for VXLAN tunneled packets.  <a href="#a829c4a817a146d1f6be4d5f2e6e0bc6d">More...</a><br /></td></tr>
<tr class="separator:a829c4a817a146d1f6be4d5f2e6e0bc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4da3e1fbe4525b488019ea8d2585da"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#acd4da3e1fbe4525b488019ea8d2585da">kVxlanTunnelHdrLen</a> = 50</td></tr>
<tr class="memdesc:acd4da3e1fbe4525b488019ea8d2585da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of the VXLAN tunnel headers.  <a href="#acd4da3e1fbe4525b488019ea8d2585da">More...</a><br /></td></tr>
<tr class="separator:acd4da3e1fbe4525b488019ea8d2585da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8ef77d02252c3085a53bf96d309ed2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e8ef77d02252c3085a53bf96d309ed2"></a>
const ::std::string&#160;</td><td class="memItemRight" valign="bottom"><b>flowStateString</b> [] = {&quot;TRIAGED&quot;, &quot;OFF&quot;, &quot;ON&quot;, &quot;UNREACHABLE&quot;, &quot;LOSS_TRIAGED&quot;, &quot;UNDEFINED&quot;}</td></tr>
<tr class="separator:a2e8ef77d02252c3085a53bf96d309ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdbb790ff2868f9e6b11c9715bb2f9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebdbb790ff2868f9e6b11c9715bb2f9a"></a>
const <a class="el" href="namespaceiron.html#a436ed3fde66cf256f942dff35d3dd4e2">EFOrdering</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultEFOrdering</b> = EF_ORDERING_DELIVERY_MARGIN</td></tr>
<tr class="separator:aebdbb790ff2868f9e6b11c9715bb2f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef35b0b6ae0db973b1a54e6bac077c63"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aef35b0b6ae0db973b1a54e6bac077c63">kDefaultQueueDelayWeight</a> = 0.1</td></tr>
<tr class="memdesc:aef35b0b6ae0db973b1a54e6bac077c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The backpressure gradient queue-delay weight for NPLB.  <a href="#aef35b0b6ae0db973b1a54e6bac077c63">More...</a><br /></td></tr>
<tr class="separator:aef35b0b6ae0db973b1a54e6bac077c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af180437d1420b210c42b5e3035843149"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#af180437d1420b210c42b5e3035843149">kDefaultQueueDelayStickinessThreshSecs</a> = 0.2</td></tr>
<tr class="memdesc:af180437d1420b210c42b5e3035843149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold queue delay before adding a stickiness term for NPLB.  <a href="#af180437d1420b210c42b5e3035843149">More...</a><br /></td></tr>
<tr class="separator:af180437d1420b210c42b5e3035843149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c49e314bc216fdfe3807ecf43b92066"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a9c49e314bc216fdfe3807ecf43b92066">kDefaultMaxLossThreshold</a> = 0.2</td></tr>
<tr class="memdesc:a9c49e314bc216fdfe3807ecf43b92066"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default maximum loss threshold for an inelastic flow.  <a href="#a9c49e314bc216fdfe3807ecf43b92066">More...</a><br /></td></tr>
<tr class="separator:a9c49e314bc216fdfe3807ecf43b92066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3beb8624ffe4fc79e1cdedeba0202b3"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ae3beb8624ffe4fc79e1cdedeba0202b3">kBpfAlgHysteresisBytes</a> = 150</td></tr>
<tr class="separator:ae3beb8624ffe4fc79e1cdedeba0202b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab361bc7a1d498c05af3aeee1680ce6d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab361bc7a1d498c05af3aeee1680ce6d0"></a>
const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ab361bc7a1d498c05af3aeee1680ce6d0">kDefaultGramPort</a> = 48901</td></tr>
<tr class="memdesc:ab361bc7a1d498c05af3aeee1680ce6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default port used for GRoup Advertisement Messages. <br /></td></tr>
<tr class="separator:ab361bc7a1d498c05af3aeee1680ce6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051239a7aa281ddc891b3aa31c079b2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a051239a7aa281ddc891b3aa31c079b2a"></a>
const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a051239a7aa281ddc891b3aa31c079b2a">kDefaultGramGrpAddr</a> = <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a>(&quot;224.77.77.77&quot;)</td></tr>
<tr class="memdesc:a051239a7aa281ddc891b3aa31c079b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default multicast group used for GRoup Advertisement Messages. <br /></td></tr>
<tr class="separator:a051239a7aa281ddc891b3aa31c079b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3a7acfc6041f9c8282123da16cdec9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f3a7acfc6041f9c8282123da16cdec9"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a7f3a7acfc6041f9c8282123da16cdec9">kDefaultNumHostMasks</a> = 8</td></tr>
<tr class="memdesc:a7f3a7acfc6041f9c8282123da16cdec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default maximum number of subnet masks allowed per bin id. <br /></td></tr>
<tr class="separator:a7f3a7acfc6041f9c8282123da16cdec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaef6a9694181fa0d2888c2730a5a8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecaef6a9694181fa0d2888c2730a5a8c"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aecaef6a9694181fa0d2888c2730a5a8c">kDefaultSendGrams</a> = true</td></tr>
<tr class="memdesc:aecaef6a9694181fa0d2888c2730a5a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating whether or not to send group advertisement messages. <br /></td></tr>
<tr class="separator:aecaef6a9694181fa0d2888c2730a5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac684c7fe67def6e182b3b02460e688a3"><td class="memItemLeft" align="right" valign="top">const ::std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ac684c7fe67def6e182b3b02460e688a3">kDefaultUdpLogUtilityDefn</a></td></tr>
<tr class="memdesc:ac684c7fe67def6e182b3b02460e688a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default LOG utility function parameters for the UDP proxy.  <a href="#ac684c7fe67def6e182b3b02460e688a3">More...</a><br /></td></tr>
<tr class="separator:ac684c7fe67def6e182b3b02460e688a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92c1e56ef432782aa7b42934a7245f4"><td class="memItemLeft" align="right" valign="top">const ::std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aa92c1e56ef432782aa7b42934a7245f4">kDefaultTcpLogUtilityDefn</a></td></tr>
<tr class="memdesc:aa92c1e56ef432782aa7b42934a7245f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default LOG utility function parameters for the TCP proxy.  <a href="#aa92c1e56ef432782aa7b42934a7245f4">More...</a><br /></td></tr>
<tr class="separator:aa92c1e56ef432782aa7b42934a7245f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b735204a5e28c773d4d2f289045fda"><td class="memItemLeft" align="right" valign="top">const ::std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a17b735204a5e28c773d4d2f289045fda">kDefaultStrapUtilityDefn</a></td></tr>
<tr class="memdesc:a17b735204a5e28c773d4d2f289045fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default STRAP utility function parameters.  <a href="#a17b735204a5e28c773d4d2f289045fda">More...</a><br /></td></tr>
<tr class="separator:a17b735204a5e28c773d4d2f289045fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8339d088411944ee27d4a86baa9221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee8339d088411944ee27d4a86baa9221"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aee8339d088411944ee27d4a86baa9221">kCurLatencyWeight</a> = 1.0</td></tr>
<tr class="memdesc:aee8339d088411944ee27d4a86baa9221"><td class="mdescLeft">&#160;</td><td class="mdescRight">The weight applied to the current measurement of latency. <br /></td></tr>
<tr class="separator:aee8339d088411944ee27d4a86baa9221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b85f86b0861e0e92b1042578d60310e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b85f86b0861e0e92b1042578d60310e"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>kNumNodesInHistory</b> = 11</td></tr>
<tr class="separator:a7b85f86b0861e0e92b1042578d60310e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfc2f5b0fb617dc2ee425b6cbe22291"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a5cfc2f5b0fb617dc2ee425b6cbe22291">kNumHistoryFields</a> = (kNumNodesInHistory + 4) / 4</td></tr>
<tr class="separator:a5cfc2f5b0fb617dc2ee425b6cbe22291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab315109e1fc40c388823943c4da7fb81"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ab315109e1fc40c388823943c4da7fb81">kHistoryFieldSizeBytes</a></td></tr>
<tr class="separator:ab315109e1fc40c388823943c4da7fb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9544429d4c25d954ab5387fb65ce424b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9544429d4c25d954ab5387fb65ce424b"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a9544429d4c25d954ab5387fb65ce424b">kHistoryEntryUnused</a> = 255</td></tr>
<tr class="memdesc:a9544429d4c25d954ab5387fb65ce424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of a history vector entry that is unused. <br /></td></tr>
<tr class="separator:a9544429d4c25d954ab5387fb65ce424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7e58451e694bc2fddfb3eb49fb5c00"><td class="memItemLeft" align="right" valign="top">const ::std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aea7e58451e694bc2fddfb3eb49fb5c00">LatencyClass_Name</a> []</td></tr>
<tr class="memdesc:aea7e58451e694bc2fddfb3eb49fb5c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the traffic type.  <a href="#aea7e58451e694bc2fddfb3eb49fb5c00">More...</a><br /></td></tr>
<tr class="separator:aea7e58451e694bc2fddfb3eb49fb5c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa195a8a44362e8ebec635e44b4642e90"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#aa195a8a44362e8ebec635e44b4642e90">kShmPPNumPkts</a> = 0x20FFF</td></tr>
<tr class="memdesc:aa195a8a44362e8ebec635e44b4642e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of packets in the shared memory packet pool.  <a href="#aa195a8a44362e8ebec635e44b4642e90">More...</a><br /></td></tr>
<tr class="separator:aa195a8a44362e8ebec635e44b4642e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9849103833e3e3bfeb9894dfd2fa69"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a1c9849103833e3e3bfeb9894dfd2fa69">kLocalPPNumPkts</a> = 1024</td></tr>
<tr class="memdesc:a1c9849103833e3e3bfeb9894dfd2fa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of packets in the local memory packet pool.  <a href="#a1c9849103833e3e3bfeb9894dfd2fa69">More...</a><br /></td></tr>
<tr class="separator:a1c9849103833e3e3bfeb9894dfd2fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fbd8ad6625e3b26cdca6d8d7228b5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5fbd8ad6625e3b26cdca6d8d7228b5d"></a>
const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#ae5fbd8ad6625e3b26cdca6d8d7228b5d">kMaxNumAmpSupportedTargets</a> = 3</td></tr>
<tr class="memdesc:ae5fbd8ad6625e3b26cdca6d8d7228b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of targets supported by AMP. <br /></td></tr>
<tr class="separator:ae5fbd8ad6625e3b26cdca6d8d7228b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa3804be6704994711c3bad12824bd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaa3804be6704994711c3bad12824bd7"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#afaa3804be6704994711c3bad12824bd7">kMaxNumRetries</a> = 15</td></tr>
<tr class="memdesc:afaa3804be6704994711c3bad12824bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of connection retries on initialization. <br /></td></tr>
<tr class="separator:afaa3804be6704994711c3bad12824bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16177b276f4312d2c4f6b5234f4ef4a5"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a16177b276f4312d2c4f6b5234f4ef4a5">kUnderdrivingThreshFrac</a> = 0.25</td></tr>
<tr class="separator:a16177b276f4312d2c4f6b5234f4ef4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716a335b65bc4209fa86f2cd9c151769"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiron.html#a716a335b65bc4209fa86f2cd9c151769">kLowVolThreshFrac</a> = 0.01</td></tr>
<tr class="separator:a716a335b65bc4209fa86f2cd9c151769"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> header file. </p>
<p>Provides the IRON software with an abstract edge interface.</p>
<p>An abstract interface class for utility functions.</p>
<p>The IRON timer header file.</p>
<p>Support for accumulating and dumping stats from a process.</p>
<p>The interface for IRON inter-process shared memory access.</p>
<p>The IRON Random Number Generator header file.</p>
<p>Statistics about actual queue depths vs values in shared memory.</p>
<p><a class="el" href="classiron_1_1QueueDepths.html" title="The QueueDepths class stores queue depth information for a set of bins. ">QueueDepths</a> Header File.</p>
<p><a class="el" href="classiron_1_1Queue.html">Queue</a> header file.</p>
<p>The IRON <a class="el" href="classiron_1_1PacketSet.html">PacketSet</a> header file.</p>
<p><a class="el" href="classiron_1_1PacketQueue.html">PacketQueue</a> header file.</p>
<p>The inter-process signaling module for packet indices.</p>
<p>The IRON ordered mash table header file.</p>
<p>The IRON ordered linked list header file.</p>
<p>The IRON mash table header file.</p>
<p>The IRON non-ordered list header file.</p>
<p><a class="el" href="classiron_1_1LatencyCacheShm.html" title="LatencyCacheShm stores the latency of the quickest path to every destination using each CAT...">LatencyCacheShm</a> header file.</p>
<p>The IRON time header file.</p>
<p>The IRON IPv4 Endpoint header file.</p>
<p>The IRON ipv4 address header file.</p>
<p>The IRON inter-process communications (IPC) module.</p>
<p>The IRON hash table header file.</p>
<p>Header file for utilities for generating xplot graphs.</p>
<p>The IRON inter-process signaling module.</p>
<p>Provides the IRON software with an edge interface implementation.</p>
<p>The IRON callback header file.</p>
<p>Provides the IRON software with various identifer-related mappings.</p>
<p>The IRON bin indexable array shared memory header file.</p>
<p>The IRON bin indexable array no-copy header file.</p>
<p>The IRON bin indexable array header file.</p>
<p>Header file for Receiver Report Message (RRM) packet utility functions.</p>
<p><a class="el" href="structiron_1_1Gradient.html" title="Define the gradient structure used in algorithms. ">Gradient</a> structure.</p>
<p><a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> header file.</p>
<p>This class contains the state and logic for implementing the <a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> (Anti-Starvation with Artificial Packets) algorithm to counter starvation of small flows.</p>
<p>Provides the IRON software with a Backpressure Forwarder implementation.</p>
<p>This class contains and manages the queues for a particular multicast group or unicast destination. There is one set of physical queues (one queue per traffic class) for each multicast group. However, the queue values used for backpressure and admission control depend on the queue depths to each destination. Therefore, the <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> for a group includes a set queue values and/or queue depths that are destination-specific. In the unicast case, only the queue depth/value for the pertinent destination will have a value.</p>
<p>This structure defines a gradient, which is used in both the forwarding algorithm and starvation computation in bin queue mgr. This gradient consists of a value, bin, patch controller, and indication about whether or not the destination is the next hop.</p>
<p>Provides a class for tracking the queue depth oscillation period to be used for queue depth smoothing.</p>
<p>With floored log utility, a flow is admitted on a logarithmic utility scale as long as the flow is being properly serviced. If the flow is not being properly servied, it will be triaged and will not be automatically restarted.</p>
<p>Provides mechanisms for creating and manipulating RRM packets.</p>
<p>With simplified trap utility, the utility is gradually increased or decreased in discrete steps, up to some maximum value. Whether it is increased or decreased is determined by k_val_ and the current queue depth at the BPF. Unlike the TRAP utility, the only required parameter is the priority, p. The other parameters are calculated or a default value is used.</p>
<p>Provides the IRON software with a simple array of copyable objects that is accessible using a single, common, bin index as provided by the <a class="el" href="classiron_1_1BinMap.html" title="Mapping of identifiers to IRON nodes and multicast groups. ">BinMap</a>.</p>
<p>Provides the IRON software with a simple array of non-copyable objects that is accessible using a single, common, bin index as provided by the <a class="el" href="classiron_1_1BinMap.html" title="Mapping of identifiers to IRON nodes and multicast groups. ">BinMap</a>.</p>
<p>Provides the IRON software with a simple array of copyable objects that is stored in shared memory and accessible using a single, common, bin index as provided by the <a class="el" href="classiron_1_1BinMap.html" title="Mapping of identifiers to IRON nodes and multicast groups. ">BinMap</a>.</p>
<p>Provides the IRON software with a simple, flexible, object-oriented callback capability. Callback methods may include zero, one, two, or three arguments.</p>
<p>Support for accessing properties from a file.</p>
<p>Class used to collect and store various statistics.</p>
<p>Provides the IRON software with the capability for separate processes on a single computer to wake each other up from their main processing loop select() calls. Short messages from the source process are passed in one direction through to the receiver process.</p>
<p>Provides a simple interface for printing a graph (for analysis or debugging purposes) as the software runs.</p>
<p>Provides the IRON software with an efficient, templated hash table implementation.</p>
<p>Provides the IRON software with an efficient, flexible, message-based inter-process communications capability.</p>
<p>Provides a simple class for storage and manipulation of IPv4 addresses within IRON.</p>
<p>Provides the IRON software with an efficient way to encapsulate the information for an IPv4 Endpoint, consisting of an IPv4 Address and a port.</p>
<p>Provides the IRON software with a time class.</p>
<p>Class for storing and using the fluid K value: the previous and current value of K, the time to start transitioning, and how long the transition should take.</p>
<p>This storage class is responsible for maintaining the minimum latency to every destination in the network. This information is based in the LSAs and CAT measurements.</p>
<p>Provides the IRON software with an efficient, templated non-ordered linked list implementation.</p>
<p>With log utility function, the utility gained from sending packets decrease on a log scale with the current queue depth.</p>
<p>Provides the IRON software with an efficient, templated mash table implementation.</p>
<p>Provides the IRON software with an efficient, templated linked list implementation.</p>
<p>Provides the IRON software with an efficient, templated ordered mash table implementation.</p>
<p>Provides the IRON software with a packet class.</p>
<p>Provides the IRON software with the capability to pass packet shared memory indices between separate processes on a single computer. When this is used to transfer a packet index, control of that packet is being logically tranferred to the receiving process.</p>
<p>Utility functions for tracking packet history.</p>
<p>Provides the IRON software with a pool of <a class="el" href="classiron_1_1Packet.html">Packet</a> objects on the heap.</p>
<p>Provides the IRON software with a pool of <a class="el" href="classiron_1_1Packet.html">Packet</a> objects in shared memory.</p>
<p>Implements a flexible queue class to serve as bins in the backpressure queue of IRON nodes. These bins are actually queues that can be configured with a drop policy. Currently, only the FIFO dequeue policy is implemented. The drop policies currently implemented are drop HEAD and drop TAIL.</p>
<p>Provides the IRON software with a container to manage a set of IRON Packets.</p>
<p>Interface for representing a <a class="el" href="classiron_1_1Queue.html">Queue</a>, which may contain packets or just virtual (zombie) sizes.</p>
<p>This class serves as storage for queue depth information for the local node. It maintains the current depth, in bytes, of each of the node's backpressure bins in a map container. It also implements the serialize and deserialize function used to create and parse QLAMs respectively.</p>
<p>This class is used to track the differences between a <a class="el" href="classiron_1_1QueueDepths.html" title="The QueueDepths class stores queue depth information for a set of bins. ">QueueDepths</a> object that is up-to-date and the queue depths values that have been written to shared memory.</p>
<p>Provides the IRON software with a Random Number Generator.</p>
<p>Provides the IRON software with a common facility for managing mutexes.</p>
<p>Provides the IRON software with access to shared memory between separate processes on a single computer.</p>
<p>Provides the IRON software with a collection of methods for manipulating std::string objects.</p>
<p>Provides the IRON software with a timer class.</p>
<p>This object will be used to store the configurable parameters and the current state needed to calculate the utility of sending packets and therefore the rate at which packets should be sent based on the depths of queues at the IRON Backpressure Forwarder. The main purpose of a utility function object is to calculate the send rate, based on the instantaneous queue depth for the destination at the local node.</p>
<p>With inelastic utility functions such as "step" and "sigmoidal", the utility is also calculated using the average queue depth and average send rate, averaged over fixed time intervals. If the average utility is less than some theshold value for a number of consecutive intervals then the flow is turned off.</p>
<p>Implements the Admission Planner (AMP) in IRON.</p>
<p>AMP runs on each IRON node and controls admission control in each of the proxies by sending and updating service definitions. AMP also acts as an intermediatary between the proxies and the Red GUI. AMP has a remote control client and a remote control server object. The client object manages connections to the IRON proxies and the server object manages connections to the red GUI.</p>
<p>AMP performs supervisory control by looking at the state of the flows (as reported by local proxies), the state of the network (as reported by the BPF) and determining which flows should be on. It signals the proxies with any necessary changes to the FlowState over the remote control interface.</p>
<p>Configuration file passed to amp_main, or else the default values will be  used. When running automated experiments, set these in system.cfg to  override the defaults." </p><pre class="fragment">                          CMD file
                             |
</pre><p> +--------&mdash;+ | | TCP proxy | +--------------&mdash;+ | (rc svr) |--------&mdash;| | +--------&mdash;+ | AMP | | | +--------&mdash;+ | | +--------&mdash;+ | TCP proxy |--------&mdash;|rc rc |----&mdash;| GUI | | (rc svr) | |client server | | rc client | +--------&mdash;+ | | +--------&mdash;+ | | +--------&mdash;+ | | | BPF |--------&mdash;| | | (rc svr) | | | +--------&mdash;+ +--------------&mdash;+</p>
<p>Implements a file transfer control application that interfaces with AMP.</p>
<p>The file transfer controller (<a class="el" href="classiron_1_1FTC.html">FTC</a>) allows a command line interface into AMP that can be used for setting the deadlines and file sizes for file transfers.</p>
<p>Implements a file transfer control application that interfaces with AMP.</p>
<p>The file transfer controller (<a class="el" href="classiron_1_1GMU.html">GMU</a>) allows a command line interface into AMP that can be used for setting the deadlines and file sizes for file transfers.</p>
<p>Supervisory Control Interface for IRON.</p>
<p>Supervisory control takes a top-down approach to managing flows in the network. It looks at all on-going flows, their utility, and the state of the network to determine which should be allowed into the network, which should be turned off, and if any that are currently off should be turned on.</p>
<p>Implements Supervisory Control for IRON.</p>
<p>Supervisory control takes a top-down approach to managing flows in the network. It looks at all on-going flows, their utility, and the state of the network to determine with should be allowed into the network, which should be turned off, and if any that are currently off should be turned on. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a945f54bc51c338f82666aa7b9ace4cbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="namespaceiron.html#a945f54bc51c338f82666aa7b9ace4cbb">iron::BinId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>N.B.: BinId is 0-based, McastId is 1-based, BinIndex (internal only) is 0-based. The type for Bin Identifiers (really IRON node identifiers). There is exactly one BinId for each IRON node. These are used for labeling traffic, tracking and directing packets, etc.</p>
<p>Valid values are from 0 to kMaxUcastBinId for IRON edge nodes, and from 0 to kMaxBinId for IRON interior nodes. The invalid value kInvalidBinId is the maximum value of the type.</p>
<p>Note: BinIds are carried on the wire. Changing this type requires changing packet formats. </p>

<p>Definition at line <a class="el" href="iron__types_8h_source.html#l00073">73</a> of file <a class="el" href="iron__types_8h_source.html">iron_types.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a5f420ded2cbb0ebfaf30509e0ce1d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">iron::BinIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type for IRON node-specific Bin Indices that are used for arrays of local information. The arrays must utilize the <a class="el" href="classiron_1_1BinIndexableArray.html" title="Templated Bin Indexable Array class. ">BinIndexableArray</a> template classes in order to work correctly.</p>
<p>Valid values are 0 to kInvalidBinIndex-1. The invalid value kInvalidBinIndex is the maximum value of the type.</p>
<p>This type is internal to each IRON node instance and is not exposed in any messages.</p>
<p>There is a one-to-one mapping between in-use BinId and McastId values and in-use BinIndex values. However, these are distinct types in order to allow BinIds and McastIds that aren't adjacent. Within each block of BinIndex values (one for unicast destination BinIds, one for IRON interior node BinIds, and one for multicast destination McastIds), the BinIndex values must be contiguous. The <a class="el" href="classiron_1_1BinIndexableArray.html" title="Templated Bin Indexable Array class. ">BinIndexableArray</a> template classes handle these three blocks of BinIndex values automatically. </p>

<p>Definition at line <a class="el" href="iron__types_8h_source.html#l00106">106</a> of file <a class="el" href="iron__types_8h_source.html">iron_types.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f12defd24be4c98a117d6219a14edb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structiron_1_1DequeuedInfo.html">iron::DequeuedInfo</a>  <a class="el" href="structiron_1_1DequeuedInfo.html">iron::DequeuedInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store information about a dequeued packet (or dequeued bytes for zombie queues) </p>
<p>Used to pass information around to accounting functions, since we may or may not have a packet. </p>

</div>
</div>
<a class="anchor" id="aacbb07180f64325df5439a0fcc7dae80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">iron::DstVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type used to store a bit vector of BinId values indicating the unicast destinations (IRON edge nodes) to which a multicast packet must be sent.</p>
<p>Note: If this type is changed, then path_controller.[h,cc] will also need to change to read/write the correct number of bits onto the wire. Anything that examines CAT headers on the wire (wireshark dissectors, for instance) would also have to be updated. </p>

<p>Definition at line <a class="el" href="iron__types_8h_source.html#l00116">116</a> of file <a class="el" href="iron__types_8h_source.html">iron_types.h</a>.</p>

</div>
</div>
<a class="anchor" id="a793d5cd02db34ad78dff98376d59727e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structiron_1_1FdEventInfo__s.html">iron::FdEventInfo_s</a>  <a class="el" href="namespaceiron.html#a793d5cd02db34ad78dff98376d59727e">iron::FdEventInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encapsulates a file descriptor and the events of interest for the file descriptor. </p>

</div>
</div>
<a class="anchor" id="a73b15497a0e8d187bfc7bd2e67514da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespaceiron.html#a73b15497a0e8d187bfc7bd2e67514da4">iron::McastId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type for Multicast Group Identifiers. There is one identifier for each multicast group, identified via a hash of the multicast group IPv4 address to avoid contention. These are used for labeling groups in QLAMs and other data on-the-wire.</p>
<p>Valid values are 1 to kMaxMcastId. The invalid value kInvalidMcastId is the minimum value of the type.</p>
<p>Note: McastIds are carried on the wire. Changing this type requires changing packet formats.</p>
<p>See also kMaxNumMcastGroups in <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>. </p>

<p>Definition at line <a class="el" href="iron__types_8h_source.html#l00087">87</a> of file <a class="el" href="iron__types_8h_source.html">iron_types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a967c03382713d10e12ed65243542344a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#a967c03382713d10e12ed65243542344a">iron::BroadcastIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for indices into the broadcast packet sequence number table based on packet types. </p>

<p>Definition at line <a class="el" href="backpressure__fwder_8h_source.html#l00084">84</a> of file <a class="el" href="backpressure__fwder_8h_source.html">backpressure_fwder.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad659e642b72c352bd1bd2644e2d06085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#ad659e642b72c352bd1bd2644e2d06085">iron::CatHeaderType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The header types for CAT packets and headers. Determined by the first byte in the buffer.</p>
<p>All CAT packet and header type values are one byte long, and are within the following hexadecimal range:</p>
<p>Range 0x30-0x3f (decimal 48-63)</p>
<p>This leaves the following ranges for other components:</p>
<p>Range 0x00-0x0f (decimal 0-15) for SLIQ headers. Range 0x10-0x1f (decimal 16-31) for BPF packets. Range 0x20-0x2f (decimal 32-47) for SLIQ headers. Range 0x40-0x4f (decimal 64-79) for IPv4 headers.</p>
<p>WARNING: Any changes to these header types must not conflict with the HeaderType definition in <a class="el" href="sliq__framer_8h_source.html">iron/sliq/src/sliq_framer.h</a> and the PacketType definition in <a class="el" href="packet_8h_source.html">iron/common/include/packet.h</a>. </p>

<p>Definition at line <a class="el" href="path__controller_8h_source.html#l00085">85</a> of file <a class="el" href="path__controller_8h_source.html">path_controller.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6ec605b16a7ca62ecb893b9bcece967e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#a6ec605b16a7ca62ecb893b9bcece967e">iron::DSCPSupportEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of IPv4 packet DSCP values we care about for IRON processing. </p>

<p>Definition at line <a class="el" href="packet_8h_source.html#l00131">131</a> of file <a class="el" href="packet_8h_source.html">packet.h</a>.</p>

</div>
</div>
<a class="anchor" id="a436ed3fde66cf256f942dff35d3dd4e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#a436ed3fde66cf256f942dff35d3dd4e2">iron::EFOrdering</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The EF Ordering enum. Modify the array of strings below if you modify the enum here. EF_ORDERING_NONE is same as receive time (no ordering) EF_ORDERING_DELIVERY_MARGIN, for ttg - ttr (default). EF_ORDERING_TTG for ttg of the packet. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00260">260</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa2092cd2da5aa3db884c7bfbcf7ec90a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#aa2092cd2da5aa3db884c7bfbcf7ec90a">iron::FdEvent_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of file descriptor events of interest. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa2092cd2da5aa3db884c7bfbcf7ec90aa37330092dc64d82268d7a7644a75be55"></a>kFdEventRead&#160;</td><td class="fielddoc">
<p>Used to express interest in data available to be read from a socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa2092cd2da5aa3db884c7bfbcf7ec90aae2ef6fbecf213207f316cce83b3e5bed"></a>kFdEventWrite&#160;</td><td class="fielddoc">
<p>Used to express interest in space becoming available in socket send buffer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa2092cd2da5aa3db884c7bfbcf7ec90aa06a1bb0dd42348aa27b3f3cb38d41ea5"></a>kFdEventReadWrite&#160;</td><td class="fielddoc">
<p>Used to express interest in data available to be read from a socket and space becoming available in socket send buffer. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="fd__event_8h_source.html#l00044">44</a> of file <a class="el" href="fd__event_8h_source.html">fd_event.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2603a9d5ad80707c1a0aa907c23833ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">iron::LatencyClass</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of the packet latency classes for IRON processing. Note that the order of the members controls the order that the <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> dequeues packets for backpressure forwarding. </p>

<p>Definition at line <a class="el" href="packet_8h_source.html#l00141">141</a> of file <a class="el" href="packet_8h_source.html">packet.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8ce939dd6d396ca6eec338d5b61f0cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#aa8ce939dd6d396ca6eec338d5b61f0cc">iron::ListOrder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The templated Ordered Linked <a class="el" href="classiron_1_1List.html" title="The templated non-ordered Linked List class. ">List</a> class. </p>
<p>This linked list class is ordered. Items should be added using the Push method.</p>
<p>This class is templated with the object C stored into links and a Typename O of the values used to order the list. Each list may be created with a boolean indicating whether the sorting values are in increasing or decreasing order.</p>
<p>C should implement the == operator for Find method.</p>
<p>The item class destructors cannot be relied upon to manage external memory. This template creates internal storage objects and manages the memory used by these internal storage objects. Any necessary memory management of the items stored in the <a class="el" href="classiron_1_1OrderedList.html">OrderedList</a> must be handled by the user of this template.</p>
<p>This class is NOT thread-safe. The enumeration indicating if there is increasing, decreasing or no ordering. </p>

<p>Definition at line <a class="el" href="ordered__list_8h_source.html#l00070">70</a> of file <a class="el" href="ordered__list_8h_source.html">ordered_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a864a6d7827d70562024605660e233435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#a864a6d7827d70562024605660e233435">iron::PacketOwner</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration used to store the current and previous owners of the packet to use for tracking packets through the system. Currently, these are at a process level.</p>
<p>If additional values are added to this enum, then the last_location_ variable must be updated to allow tracking location across more components. </p>

<p>Definition at line <a class="el" href="packet_8h_source.html#l00186">186</a> of file <a class="el" href="packet_8h_source.html">packet.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba594a8c6649f79e4d75062cd27f83e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#aba594a8c6649f79e4d75062cd27f83e1">iron::PacketRecvTimeMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration to indicate how the receive time in a packet should be set, if at all. This is used in the <a class="el" href="classiron_1_1PacketPool.html#aaec8c15040c71e56e36b327879744de9" title="Get a Packet object from the pool. ">PacketPool::Get()</a> method and the <a class="el" href="classiron_1_1PacketPool.html#aff717d09c7fc12c2a2bdaf6592030b2b" title="Create a deep copy of a Packet. ">PacketPool::Clone()</a> methods. PACKET_COPY_TIMESTAMP is only used when cloning packets. </p>

<p>Definition at line <a class="el" href="packet_8h_source.html#l00172">172</a> of file <a class="el" href="packet_8h_source.html">packet.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae0af8b0162a34b134de9726d5aeab1d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#ae0af8b0162a34b134de9726d5aeab1d5">iron::PacketType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of the supported packet types. Determined by the first byte in the buffer.</p>
<p>All backpressure forwarder packet type values are one byte long, and are within the following hexadecimal range:</p>
<p>Range 0x10-0x1f (decimal 16-31)</p>
<p>This leaves the following ranges for other components:</p>
<p>Range 0x00-0x0f (decimal 0-15) for SLIQ headers. Range 0x20-0x2f (decimal 32-47) for SLIQ headers. Range 0x30-0x3f (decimal 48-63) for CAT packets and headers. Range 0x40-0x4f (decimal 64-79) for IPv4 packets.</p>
<p>WARNING: Any changes to these header types must not conflict with the HeaderType definition in <a class="el" href="sliq__framer_8h_source.html">iron/sliq/src/sliq_framer.h</a> and the CatHeaderType definition in <a class="el" href="path__controller_8h_source.html">iron/bpf/src/path_controller.h</a>. </p>

<p>Definition at line <a class="el" href="packet_8h_source.html#l00104">104</a> of file <a class="el" href="packet_8h_source.html">packet.h</a>.</p>

</div>
</div>
<a class="anchor" id="af49dbf2efb0e78e4445fe2f51d8e490f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceiron.html#af49dbf2efb0e78e4445fe2f51d8e490f">iron::XPLOT_COLOR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Color names to match the numbers encoded in xplot. (This is for the colored on black graphs. The number-to-color map changes when converting to PS with colored on white.) </p>

<p>Definition at line <a class="el" href="genxplot_8h_source.html#l00060">60</a> of file <a class="el" href="genxplot_8h_source.html">genxplot.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6c67dd22e7e90c21d87ddcc686b58d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A reference to the left <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object. </td></tr>
    <tr><td class="paramname">right</td><td>A reference to the right <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the addresses are different, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ipv4__address_8cc_source.html#l00170">170</a> of file <a class="el" href="ipv4__address_8cc_source.html">ipv4_address.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac4c4ffd219e83622dcd2402691827da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inequality operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A reference to the left <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> object. </td></tr>
    <tr><td class="paramname">right</td><td>A reference to the right <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the addresses are different, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ipv4__endpoint_8cc_source.html#l00192">192</a> of file <a class="el" href="ipv4__endpoint_8cc_source.html">ipv4_endpoint.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a512351be6487eac026aa652686e96f50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A reference to the left <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object. </td></tr>
    <tr><td class="paramname">right</td><td>A reference to the right <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the left address is less than the right address, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ipv4__address_8cc_source.html#l00177">177</a> of file <a class="el" href="ipv4__address_8cc_source.html">ipv4_address.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a075849869ad27d8abe749a78d1c22466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A reference to the left <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object. </td></tr>
    <tr><td class="paramname">right</td><td>A reference to the right <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the left address is less than or equal to the right address, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ipv4__address_8cc_source.html#l00189">189</a> of file <a class="el" href="ipv4__address_8cc_source.html">ipv4_address.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6b92ef0dda47948922cccb8405a5de75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A reference to the left <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object. </td></tr>
    <tr><td class="paramname">right</td><td>A reference to the right <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the addresses are equal, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ipv4__address_8cc_source.html#l00163">163</a> of file <a class="el" href="ipv4__address_8cc_source.html">ipv4_address.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aceb76ace5528e8c690857a8a84c261e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A reference to the left <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> object. </td></tr>
    <tr><td class="paramname">right</td><td>A reference to the right <a class="el" href="classiron_1_1Ipv4Endpoint.html">Ipv4Endpoint</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the addresses are equal, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ipv4__endpoint_8cc_source.html#l00185">185</a> of file <a class="el" href="ipv4__endpoint_8cc_source.html">ipv4_endpoint.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a953e7491ab2e9e21869aa644cf6dbb54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A reference to the left <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object. </td></tr>
    <tr><td class="paramname">right</td><td>A reference to the right <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the left address is greater than the right address, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ipv4__address_8cc_source.html#l00183">183</a> of file <a class="el" href="ipv4__address_8cc_source.html">ipv4_address.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afc71c51535171077c90ff3684da62a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>A reference to the left <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object. </td></tr>
    <tr><td class="paramname">right</td><td>A reference to the right <a class="el" href="classiron_1_1Ipv4Address.html">Ipv4Address</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the left address is greater than or equal to the right address, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ipv4__address_8cc_source.html#l00195">195</a> of file <a class="el" href="ipv4__address_8cc_source.html">ipv4_address.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab3423fc28fc4a092f890863ffd15ad82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t iron::UNUSED </td>
          <td>(</td>
          <td class="paramtype">kStartTime&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximate system start time, to be used for drawing graphs. </p>
<p>Used to normalize times when logging values to be graphed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ae3beb8624ffe4fc79e1cdedeba0202b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t iron::kBpfAlgHysteresisBytes = 150</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default algorithm hysteresis, or minimal queue differential, in bytes, with a neighbor required before transmitting a packet to that neighbor. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00305">305</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c49e314bc216fdfe3807ecf43b92066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double iron::kDefaultMaxLossThreshold = 0.2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default maximum loss threshold for an inelastic flow. </p>
<p>This is used in the UDP proxy and AMP in utility functions where a delta value is not specified. An inelastic flow can lose at most this fraction of the nominal rate for it to be considered to be properly serviced. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00300">300</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a059be7aef7493c603b62c58c116f59e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t iron::kDefaultPacketStartBytes = 32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default length reserved at the start of each <a class="el" href="classiron_1_1Packet.html">Packet</a> buffer. Used for prepending headers to packets (such as CAT headers to IPv4 packets). </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00196">196</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="af180437d1420b210c42b5e3035843149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double iron::kDefaultQueueDelayStickinessThreshSecs = 0.2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threshold queue delay before adding a stickiness term for NPLB. </p>
<p>This is parameter d_{max} in the paper "No Packet Left Behind". (In usec rather than time slots, since we are essentially using a usec as a time slot). If the difference between the queue delay on the first packet dequeued and the first packet remaining in the queue is greater than this value, then some stickiness will be added to the gradient, meaning later packets will sit in the queue for less time. Increasing threshold this means we get less stickiness, so higher latency for packets facing potential starvation. Decreasing this will decrease latency for these packets at the expense of latency for packets for more heavily utilized bins. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00292">292</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="aef35b0b6ae0db973b1a54e6bac077c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double iron::kDefaultQueueDelayWeight = 0.1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The backpressure gradient queue-delay weight for NPLB. </p>
<p>Ignored unless QueueDepthManager = NPLB.</p>
<p>This is how much weight to place on the queue-delay term in the backpressure gradients. This will be equally weighted to the queue depth term when set to [drain-rate / 1x10^6], since the delay term reflects how long a packet has been sitting first in the queue in micro seconds, and the queue depths are in bytes. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00278">278</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a17b735204a5e28c773d4d2f289045fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string iron::kDefaultStrapUtilityDefn</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;1/1;1500;0;0;120;0;type=STRAP:p=5:label=mgen_flow_1&quot;</span></div></div><!-- fragment -->
<p>The default STRAP utility function parameters. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00333">333</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa92c1e56ef432782aa7b42934a7245f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string iron::kDefaultTcpLogUtilityDefn</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;1/1;1500;0;0;120;0;type=LOG:a=20:m=10000000:p=1:label=default_service&quot;</span></div></div><!-- fragment -->
<p>The default LOG utility function parameters for the TCP proxy. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00329">329</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac684c7fe67def6e182b3b02460e688a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string iron::kDefaultUdpLogUtilityDefn</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;1/1;1500;0;0;120;0;type=LOG:a=20:m=10000000:p=1:label=default_service&quot;</span></div></div><!-- fragment -->
<p>The default LOG utility function parameters for the UDP proxy. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00325">325</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a60f26138a5e61d42d6715ae67fd69088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool iron::kDefaultZombieCompression = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable <a class="el" href="classiron_1_1Zombie.html" title="Class of static utility functions for creating zombie packets. ">Zombie</a> compression by default. Not config tunable because there is no obvious advantage not to enable compression. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00220">220</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7dc5150369a6f9520f8248c3d1d1bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool iron::kDirectAccessQueueDepths = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if we want to access queue depths directly in shared memory. False if we want to periodically copy to local memory and access from there. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00162">162</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84b0ca85efa5c3ce1fa41b4f9e7757b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t iron::kDstVecBitsUsed = 24</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Of the bits in the DstVec, this is the maximum number of bits to be used to record destinations BinIds. This constant is necessary in order to use a specific number of bits for which we don't have a standard integer type. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00090">90</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab315109e1fc40c388823943c4da7fb81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t iron::kHistoryFieldSizeBytes</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    (((kNumNodesInHistory / 4) + 1) * 4) - 1</div></div><!-- fragment --><p>How big is the history field in bytes? 1,2,3 -&gt; 3B 4,5,6,7 -&gt; 7B 8,9,10,11 -&gt; 11B </p>

<p>Definition at line <a class="el" href="packet_8h_source.html#l00080">80</a> of file <a class="el" href="packet_8h_source.html">packet.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c9849103833e3e3bfeb9894dfd2fa69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t iron::kLocalPPNumPkts = 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of packets in the local memory packet pool. </p>
<p>This MUST not be larger than the largest number representable in type PktMemIndex. This MUST be small enough that each required process can have this many packets from the pool without exceeding ShmPPNumPkts. </p>

<p>Definition at line <a class="el" href="packet__pool__shm_8h_source.html#l00071">71</a> of file <a class="el" href="packet__pool__shm_8h_source.html">packet_pool_shm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a716a335b65bc4209fa86f2cd9c151769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double iron::kLowVolThreshFrac = 0.01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An elastic flow is considered to be a low volume flow if it is underdriving and sending at a rate less that this fraction of the total outbound capacity. </p>

<p>Definition at line <a class="el" href="svcr_8h_source.html#l00070">70</a> of file <a class="el" href="svcr_8h_source.html">svcr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0c0b6aa164ff1fdbdea2a60966b109f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t iron::kMaxBinId = UINT8_MAX - 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum value of a BinId. Except for unicast destinations (IRON edge nodes), valid BinIds are 0 to kMaxBinId.</p>
<p>See also <a class="el" href="iron__types_8h_source.html">iron_types.h</a> typedef BinId. The BinId type must be able to hold the value of this constant.</p>
<p>This is also limited, and checked during <a class="el" href="classiron_1_1BinMap.html" title="Mapping of identifiers to IRON nodes and multicast groups. ">BinMap</a> initialization, by the value of kInvalidBinId. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00137">137</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="afaeffd5619a163e97928d8407f7f33db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t iron::kMaxMcastId = UINT32_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum value of a McastId. Valid McastIds are 0 to kMaxMcastId.</p>
<p>See also <a class="el" href="iron__types_8h_source.html">iron_types.h</a> typedef McastId. The McastId type must be able to hold the value of this constant. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00143">143</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2865719ab2ac5f7ba7c7060f3129a96e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t iron::kMaxNumDsts = <a class="el" href="namespaceiron.html#a84b0ca85efa5c3ce1fa41b4f9e7757b5">kDstVecBitsUsed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of supported IRON node unicast destinations. These are IRON edge nodes only, not IRON interior nodes. Each destination is uniquely identified via a BinId. Statically initialized arrays to hold per-IRON-edge-node values (i.e., per-unicast-BinIndex) can be allocated using this size.</p>
<p>See also <a class="el" href="iron__types_8h_source.html">iron_types.h</a> typedef BinIndex. The BinIndex type must be able to hold the value of this constant plus kMaxNumIntNodes and kMaxNumMcastGroups. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00101">101</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4905c835ec1940025a80ef542368380d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t iron::kMaxNumIntNodes = 24</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of supported IRON interior nodes. Each interior node is uniquely identified via a BinId.</p>
<p>See also <a class="el" href="iron__types_8h_source.html">iron_types.h</a> typedef BinIndex. The BinIndex type must be able to hold the value of this constant plus kMaxNumDsts and kMaxNumMcastGroups. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00109">109</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa6ed348b625af16e3ac441c28f97e060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t iron::kMaxNumMcastGroups = 16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of supported multicast groups, each of which can be uniquely identified via a McastId. Statically initialized arrays to hold per-multicast-group values (i.e., per-mcast-BinIndex) can be allocated using this size.</p>
<p>See also <a class="el" href="iron__types_8h_source.html">iron_types.h</a> typedef BinIndex. The BinIndex type must be able to hold the value of this constant plus kMaxNumDsts and kMaxNumIntNodes. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00119">119</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4f40b192e653f3a599664181613641d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t iron::kMaxUcastBinId = <a class="el" href="namespaceiron.html#a84b0ca85efa5c3ce1fa41b4f9e7757b5">kDstVecBitsUsed</a> - 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum value of a BinId for a unicast destination (IRON edge node). Valid BinIds for unicast destinations are 0 to kMaxUcastBinId.</p>
<p>This is also limited, and checked during <a class="el" href="classiron_1_1BinMap.html" title="Mapping of identifiers to IRON nodes and multicast groups. ">BinMap</a> initialization, by the size kDstVecBitsUsed, since we currently use the BinId as the bit position in the DstVec bit vector. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00127">127</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5cfc2f5b0fb617dc2ee425b6cbe22291"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t iron::kNumHistoryFields = (kNumNodesInHistory + 4) / 4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of 4B words used to represent the history vector. 1,2,3 -&gt; 1 x 4B 4,5,6,7 -&gt; 2 x 4B 8,9,10,11 -&gt; 3 x 4B </p>

<p>Definition at line <a class="el" href="packet_8h_source.html#l00074">74</a> of file <a class="el" href="packet_8h_source.html">packet.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa195a8a44362e8ebec635e44b4642e90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t iron::kShmPPNumPkts = 0x20FFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of packets in the shared memory packet pool. </p>
<p>This MUST not be larger than the largest number representable in type PktMemIndex. </p>

<p>Definition at line <a class="el" href="packet__pool__shm_8h_source.html#l00064">64</a> of file <a class="el" href="packet__pool__shm_8h_source.html">packet_pool_shm.h</a>.</p>

</div>
</div>
<a class="anchor" id="a16177b276f4312d2c4f6b5234f4ef4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double iron::kUnderdrivingThreshFrac = 0.25</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An elastic flow is considered to be underdriving if is sending at a rate less than this fraction of the rate it should be sending at, given the current queue depth. This is a very lenient threshold as the admission rate can vary as the queue changes. </p>

<p>Definition at line <a class="el" href="svcr_8h_source.html#l00065">65</a> of file <a class="el" href="svcr_8h_source.html">svcr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a829c4a817a146d1f6be4d5f2e6e0bc6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t iron::kVxlanTunnelDstPort = 8472</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The UDP destination port for VXLAN tunneled packets. </p>
<p>Note that Linux uses destination port 8472 for VXLAN tunnels instead of the IANA-assigned port of 4789. </p>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00230">230</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="acd4da3e1fbe4525b488019ea8d2585da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t iron::kVxlanTunnelHdrLen = 50</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The length of the VXLAN tunnel headers. </p>
<p>The VXLAN tunnel headers include the following:</p><ul>
<li>Outer IPv4 Header (20 bytes)</li>
<li>UDP Header (8 bytes)</li>
<li>VXLAN Header (8 bytes)</li>
<li>Inner Ethernet Header (14 bytes) </li>
</ul>

<p>Definition at line <a class="el" href="iron__constants_8h_source.html#l00239">239</a> of file <a class="el" href="iron__constants_8h_source.html">iron_constants.h</a>.</p>

</div>
</div>
<a class="anchor" id="aea7e58451e694bc2fddfb3eb49fb5c00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ::std::string iron::LatencyClass_Name[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    {<span class="stringliteral">&quot;critical&quot;</span>, <span class="stringliteral">&quot;control&quot;</span>, <span class="stringliteral">&quot;low-latency&quot;</span>, <span class="stringliteral">&quot;ZombieExp&quot;</span>, <span class="stringliteral">&quot;Zombie-NPLB-LS&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;Zombie-ZLR-LS&quot;</span>, <span class="stringliteral">&quot;normal-latency&quot;</span>, <span class="stringliteral">&quot;ZombieRcvd&quot;</span>,</div><div class="line">     <span class="stringliteral">&quot;ZombieNPLB&quot;</span>, <span class="stringliteral">&quot;ZombieZLR&quot;</span>, <span class="stringliteral">&quot;in-error&quot;</span>, <span class="stringliteral">&quot;unset latency&quot;</span>}</div></div><!-- fragment -->
<p>The name of the traffic type. </p>

<p>Definition at line <a class="el" href="packet_8h_source.html#l00163">163</a> of file <a class="el" href="packet_8h_source.html">packet.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceiron.html">iron</a></li>
    <li class="footer">Generated on Fri Feb 26 2021 11:31:58 for IRON by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
