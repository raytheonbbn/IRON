<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>IRON: iron::BinQueueMgr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IRON
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classiron_1_1BinQueueMgr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classiron_1_1BinQueueMgr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iron::BinQueueMgr Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> class stores and manages the queues for a.  
 <a href="classiron_1_1BinQueueMgr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for iron::BinQueueMgr:</div>
<div class="dyncontent">
<div class="center"><img src="classiron_1_1BinQueueMgr__inherit__graph.png" border="0" usemap="#iron_1_1BinQueueMgr_inherit__map" alt="Inheritance graph"/></div>
<map name="iron_1_1BinQueueMgr_inherit__map" id="iron_1_1BinQueueMgr_inherit__map">
<area shape="rect" id="node2" href="classiron_1_1EWMABinQueueMgr.html" title="Queue manager using an exponential weighted moving average. This algorithm maintains a smoothed weigh..." alt="" coords="5,80,177,107"/>
<area shape="rect" id="node3" href="classiron_1_1HvyballBinQueueMgr.html" title="HvyballBinQueueMgr class to implement the HvyballBinQueueMgr algorithm for latency reduction..." alt="" coords="201,80,376,107"/>
<area shape="rect" id="node4" href="classiron_1_1NPLBBinQueueMgr.html" title="NPLBBinQueueMgr class to implement the No Packet Left Behind algorithm for avoiding starvation..." alt="" coords="401,80,566,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for iron::BinQueueMgr:</div>
<div class="dyncontent">
<div class="center"><img src="classiron_1_1BinQueueMgr__coll__graph.png" border="0" usemap="#iron_1_1BinQueueMgr_coll__map" alt="Collaboration graph"/></div>
<map name="iron_1_1BinQueueMgr_coll__map" id="iron_1_1BinQueueMgr_coll__map">
<area shape="rect" id="node2" href="structiron_1_1LatencyQueue.html" title="iron::LatencyQueue" alt="" coords="71,184,205,211"/>
<area shape="rect" id="node3" href="classiron_1_1Queue.html" title="iron::Queue" alt="" coords="83,95,172,121"/>
<area shape="rect" id="node4" href="classiron_1_1PacketPool.html" title="iron::PacketPool" alt="" coords="5,5,124,32"/>
<area shape="rect" id="node5" href="classiron_1_1BinMap.html" title="Mapping of identifiers to IRON nodes and multicast groups. " alt="" coords="229,184,324,211"/>
<area shape="rect" id="node6" href="classiron_1_1QueueDepths.html" title="The QueueDepths class stores queue depth information for a set of bins. " alt="" coords="349,184,479,211"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af89c2870df5ec05757ab465f8c6a6335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#af89c2870df5ec05757ab465f8c6a6335">BinQueueMgr</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin_idx, <a class="el" href="classiron_1_1PacketPool.html">PacketPool</a> &amp;packet_pool, <a class="el" href="classiron_1_1BinMap.html">BinMap</a> &amp;bin_map)</td></tr>
<tr class="memdesc:af89c2870df5ec05757ab465f8c6a6335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#af89c2870df5ec05757ab465f8c6a6335">More...</a><br /></td></tr>
<tr class="separator:af89c2870df5ec05757ab465f8c6a6335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0c95c2e7cfe9f52ca404d5adef4c12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e0c95c2e7cfe9f52ca404d5adef4c12"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a5e0c95c2e7cfe9f52ca404d5adef4c12">~BinQueueMgr</a> ()</td></tr>
<tr class="memdesc:a5e0c95c2e7cfe9f52ca404d5adef4c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a5e0c95c2e7cfe9f52ca404d5adef4c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed49d2293e9f97ceb86b16a5a45c6bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#aed49d2293e9f97ceb86b16a5a45c6bda">set_support_ef</a> (bool support)</td></tr>
<tr class="memdesc:aed49d2293e9f97ceb86b16a5a45c6bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set support for EF-traffic (enqueue in EF queues).  <a href="#aed49d2293e9f97ceb86b16a5a45c6bda">More...</a><br /></td></tr>
<tr class="separator:aed49d2293e9f97ceb86b16a5a45c6bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dadcb1d68a1e01dba26f45d1e959772"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a9dadcb1d68a1e01dba26f45d1e959772">Enqueue</a> (<a class="el" href="classiron_1_1Packet.html">Packet</a> *pkt)</td></tr>
<tr class="memdesc:a9dadcb1d68a1e01dba26f45d1e959772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a packet to a bin.  <a href="#a9dadcb1d68a1e01dba26f45d1e959772">More...</a><br /></td></tr>
<tr class="separator:a9dadcb1d68a1e01dba26f45d1e959772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d1b338ee73237329b8353510b30a69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#af3d1b338ee73237329b8353510b30a69">Peek</a> ()</td></tr>
<tr class="memdesc:af3d1b338ee73237329b8353510b30a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next packet from a specific bin looking from low to high latency.  <a href="#af3d1b338ee73237329b8353510b30a69">More...</a><br /></td></tr>
<tr class="separator:af3d1b338ee73237329b8353510b30a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd810c389fd0e0ac9966658bf8335fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#acd810c389fd0e0ac9966658bf8335fb0">Peek</a> (const uint8_t lat)</td></tr>
<tr class="memdesc:acd810c389fd0e0ac9966658bf8335fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next packet from a specific bin for a specific latency queue.  <a href="#acd810c389fd0e0ac9966658bf8335fb0">More...</a><br /></td></tr>
<tr class="separator:acd810c389fd0e0ac9966658bf8335fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682704689225d39a44f4d13259ef2ba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a682704689225d39a44f4d13259ef2ba6">is_multicast</a> ()</td></tr>
<tr class="memdesc:a682704689225d39a44f4d13259ef2ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the bin queue mgr is associated with a multicast destination.  <a href="#a682704689225d39a44f4d13259ef2ba6">More...</a><br /></td></tr>
<tr class="separator:a682704689225d39a44f4d13259ef2ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756a25a969220ab960585aec66ee1e19"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a756a25a969220ab960585aec66ee1e19">GetTotalDequeueSize</a> (const uint8_t lat)</td></tr>
<tr class="memdesc:a756a25a969220ab960585aec66ee1e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the bytes for this bin and latency class available for dequeue.  <a href="#a756a25a969220ab960585aec66ee1e19">More...</a><br /></td></tr>
<tr class="separator:a756a25a969220ab960585aec66ee1e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2f7816816f8fee51e03575f3bf696"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a91f2f7816816f8fee51e03575f3bf696">GetNextDequeueSize</a> (const uint8_t lat)</td></tr>
<tr class="memdesc:a91f2f7816816f8fee51e03575f3bf696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the potential size of the next packet for this bin and latency class.  <a href="#a91f2f7816816f8fee51e03575f3bf696">More...</a><br /></td></tr>
<tr class="separator:a91f2f7816816f8fee51e03575f3bf696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438b0a1528e9d45812133caf314bf956"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a438b0a1528e9d45812133caf314bf956">GetNextDequeueSize</a> (const uint8_t lat, <a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin_index)</td></tr>
<tr class="memdesc:a438b0a1528e9d45812133caf314bf956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the potential size of the next packet for this bin and latency class.  <a href="#a438b0a1528e9d45812133caf314bf956">More...</a><br /></td></tr>
<tr class="separator:a438b0a1528e9d45812133caf314bf956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40d4385a5512bcc2fb04323862e5cf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#af40d4385a5512bcc2fb04323862e5cf7">PrepareIteration</a> (uint8_t lat)</td></tr>
<tr class="memdesc:af40d4385a5512bcc2fb04323862e5cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare an iterator to the queue, starting from the back.  <a href="#af40d4385a5512bcc2fb04323862e5cf7">More...</a><br /></td></tr>
<tr class="separator:af40d4385a5512bcc2fb04323862e5cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec8d5fb64aaa8028adcee04114d497b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a3ec8d5fb64aaa8028adcee04114d497b">PeekNext</a> (uint8_t lat, <a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> &amp;ws)</td></tr>
<tr class="memdesc:a3ec8d5fb64aaa8028adcee04114d497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek the next element during a walk.  <a href="#a3ec8d5fb64aaa8028adcee04114d497b">More...</a><br /></td></tr>
<tr class="separator:a3ec8d5fb64aaa8028adcee04114d497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608582bb5110e8b2f6f8f57b5664eeab"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a608582bb5110e8b2f6f8f57b5664eeab">DropFromQueue</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat, uint32_t max_size_bytes, <a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a> dst_vec)</td></tr>
<tr class="memdesc:a608582bb5110e8b2f6f8f57b5664eeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop bytes from the queue for the specified latency.  <a href="#a608582bb5110e8b2f6f8f57b5664eeab">More...</a><br /></td></tr>
<tr class="separator:a608582bb5110e8b2f6f8f57b5664eeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bbe93e26e5f7631df9eb9ab0c832e5"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ad8bbe93e26e5f7631df9eb9ab0c832e5">DropFromQueue</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat, uint32_t max_size_bytes)</td></tr>
<tr class="memdesc:ad8bbe93e26e5f7631df9eb9ab0c832e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop bytes from the queue for the specified latency.  <a href="#ad8bbe93e26e5f7631df9eb9ab0c832e5">More...</a><br /></td></tr>
<tr class="separator:ad8bbe93e26e5f7631df9eb9ab0c832e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e8faf0193b6b98d6bf85f08eb9fa03"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ab1e8faf0193b6b98d6bf85f08eb9fa03">DropFromQueue</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat)</td></tr>
<tr class="memdesc:ab1e8faf0193b6b98d6bf85f08eb9fa03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop bytes from the queue for the specified latency.  <a href="#ab1e8faf0193b6b98d6bf85f08eb9fa03">More...</a><br /></td></tr>
<tr class="separator:ab1e8faf0193b6b98d6bf85f08eb9fa03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33c388bdeb5a079e56923d714906237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#af33c388bdeb5a079e56923d714906237">DequeueAtCurrentIterator</a> (uint8_t lat)</td></tr>
<tr class="memdesc:af33c388bdeb5a079e56923d714906237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue the element at the iterator in the walk and set the iterator to the next element.  <a href="#af33c388bdeb5a079e56923d714906237">More...</a><br /></td></tr>
<tr class="separator:af33c388bdeb5a079e56923d714906237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7859caf0293f9abdba8f0e43e1b25a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#acb7859caf0293f9abdba8f0e43e1b25a">GetFrontIterator</a> (uint8_t lat)</td></tr>
<tr class="memdesc:acb7859caf0293f9abdba8f0e43e1b25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the queue iterator at the front of the queue to point where the dequeue should happen. This method does not require to call PrepareIteration first.  <a href="#acb7859caf0293f9abdba8f0e43e1b25a">More...</a><br /></td></tr>
<tr class="separator:acb7859caf0293f9abdba8f0e43e1b25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e09edbb679dd122b1bb70799b18db5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a52e09edbb679dd122b1bb70799b18db5">GetIterator</a> (uint8_t lat, <a class="el" href="classiron_1_1Packet.html">Packet</a> *pkt, <a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> &amp;qws)</td></tr>
<tr class="memdesc:a52e09edbb679dd122b1bb70799b18db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the queue iterator pointing to a given packet, where the dequeue should happen. Note: This does not require calling PrepareIterator first and it walks the whole queue until it finds the packet. This method is intended to find the iterator where a packet was newly enqueued in the CRITICAL queue.  <a href="#a52e09edbb679dd122b1bb70799b18db5">More...</a><br /></td></tr>
<tr class="separator:a52e09edbb679dd122b1bb70799b18db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22412eb4e2da5368901c13ed20ca6ac1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a22412eb4e2da5368901c13ed20ca6ac1">Dequeue</a> ()</td></tr>
<tr class="memdesc:a22412eb4e2da5368901c13ed20ca6ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue a packet from a specific bin.  <a href="#a22412eb4e2da5368901c13ed20ca6ac1">More...</a><br /></td></tr>
<tr class="separator:a22412eb4e2da5368901c13ed20ca6ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb31492e730a82e8c843678e0f8a0a68"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#aeb31492e730a82e8c843678e0f8a0a68">Dequeue</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat, uint32_t max_size_bytes=UINT32_MAX, <a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a> dst_vec=0)</td></tr>
<tr class="memdesc:aeb31492e730a82e8c843678e0f8a0a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue a packet from a specific bin from a specific latency queue.  <a href="#aeb31492e730a82e8c843678e0f8a0a68">More...</a><br /></td></tr>
<tr class="separator:aeb31492e730a82e8c843678e0f8a0a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcb58d3070da0405111efe0770e5d3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a1bcb58d3070da0405111efe0770e5d3b">ZombifyPacket</a> (<a class="el" href="classiron_1_1Packet.html">Packet</a> *pkt)</td></tr>
<tr class="memdesc:a1bcb58d3070da0405111efe0770e5d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a packet into a <a class="el" href="classiron_1_1Zombie.html" title="Class of static utility functions for creating zombie packets. ">Zombie</a> packet, that is serviced in last latency queue.  <a href="#a1bcb58d3070da0405111efe0770e5d3b">More...</a><br /></td></tr>
<tr class="separator:a1bcb58d3070da0405111efe0770e5d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef5a7e11d12745b907e22077f3ae034"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a0ef5a7e11d12745b907e22077f3ae034">CriticalizePacket</a> (<a class="el" href="classiron_1_1Packet.html">Packet</a> *pkt)</td></tr>
<tr class="memdesc:a0ef5a7e11d12745b907e22077f3ae034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a packet into a Critical packet, that is to be serviced in first traffic type queue.  <a href="#a0ef5a7e11d12745b907e22077f3ae034">More...</a><br /></td></tr>
<tr class="separator:a0ef5a7e11d12745b907e22077f3ae034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dea9dc664566f890206423f7bdf30a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ab1dea9dc664566f890206423f7bdf30a">DequeueAtIterator</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat, <a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> &amp;qws, <a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a> send_to=0)</td></tr>
<tr class="memdesc:ab1dea9dc664566f890206423f7bdf30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue the packet placed at the iterator. Memory ownership quits the queue to go with the caller.  <a href="#ab1dea9dc664566f890206423f7bdf30a">More...</a><br /></td></tr>
<tr class="separator:ab1dea9dc664566f890206423f7bdf30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbfb6586aeb8b2d53fa6631b17493cd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#aacbfb6586aeb8b2d53fa6631b17493cd">depth_packets</a> () const </td></tr>
<tr class="separator:aacbfb6586aeb8b2d53fa6631b17493cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76971fb3f44023c39ac7692886ced5c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a76971fb3f44023c39ac7692886ced5c8">ContainsNonZombies</a> () const </td></tr>
<tr class="memdesc:a76971fb3f44023c39ac7692886ced5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue contains any LS (and lower latency) packets NOT INCLUDING LS zombies.  <a href="#a76971fb3f44023c39ac7692886ced5c8">More...</a><br /></td></tr>
<tr class="separator:a76971fb3f44023c39ac7692886ced5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c710f5a699adc5c81c194e44736621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a37c710f5a699adc5c81c194e44736621">ContainsLSNonZombies</a> () const </td></tr>
<tr class="memdesc:a37c710f5a699adc5c81c194e44736621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue contains any LS (and lower latency) packets NOT INCLUDING LS zombies.  <a href="#a37c710f5a699adc5c81c194e44736621">More...</a><br /></td></tr>
<tr class="separator:a37c710f5a699adc5c81c194e44736621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bc003cf1fa5e05543631383adee660"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ac0bc003cf1fa5e05543631383adee660">ContainsPacketsWithTtypes</a> (const <a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> *ttypes_to_query, uint8_t num_types_to_query) const </td></tr>
<tr class="memdesc:ac0bc003cf1fa5e05543631383adee660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue contains any packets in the given set of traffic types.  <a href="#ac0bc003cf1fa5e05543631383adee660">More...</a><br /></td></tr>
<tr class="separator:ac0bc003cf1fa5e05543631383adee660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b257049f26dfdeb36c173c9b2249cc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a76b257049f26dfdeb36c173c9b2249cc">GetTtypeDepthBytes</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> dst_to_get, const <a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> *ttypes_to_get, uint8_t num_ttypes_to_get)</td></tr>
<tr class="memdesc:a76b257049f26dfdeb36c173c9b2249cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of bytes enqueued in a set of latency queues.  <a href="#a76b257049f26dfdeb36c173c9b2249cc">More...</a><br /></td></tr>
<tr class="separator:a76b257049f26dfdeb36c173c9b2249cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ffb9dc591bb4c0438155baabf7cefe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a93ffb9dc591bb4c0438155baabf7cefe">GetQueueDepths</a> ()</td></tr>
<tr class="memdesc:a93ffb9dc591bb4c0438155baabf7cefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depths of all bins.  <a href="#a93ffb9dc591bb4c0438155baabf7cefe">More...</a><br /></td></tr>
<tr class="separator:a93ffb9dc591bb4c0438155baabf7cefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb62c0ec935d82ae7a9fb6ee3b2ec85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a8bb62c0ec935d82ae7a9fb6ee3b2ec85">GetNbrQueueDepths</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> nbr_bin_idx)</td></tr>
<tr class="memdesc:a8bb62c0ec935d82ae7a9fb6ee3b2ec85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the queue depths for a neighbor bin index for this unicast or multicast destination.  <a href="#a8bb62c0ec935d82ae7a9fb6ee3b2ec85">More...</a><br /></td></tr>
<tr class="separator:a8bb62c0ec935d82ae7a9fb6ee3b2ec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571700557f88bb432c5f263aea59cc20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a571700557f88bb432c5f263aea59cc20">set_nbr_queue_depths</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> nbr_bin_idx, <a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a> *qd)</td></tr>
<tr class="memdesc:a571700557f88bb432c5f263aea59cc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the queue depth object for a given neighbor bin index.  <a href="#a571700557f88bb432c5f263aea59cc20">More...</a><br /></td></tr>
<tr class="separator:a571700557f88bb432c5f263aea59cc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68105dcf547ca16ee8c23fb86ee7196"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#af68105dcf547ca16ee8c23fb86ee7196">GetQueueDepthsForBpfQlam</a> ()</td></tr>
<tr class="memdesc:af68105dcf547ca16ee8c23fb86ee7196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the queue depths to be used to generate a QLAM to BPF. Memory ownership is transferred to the calling object. However, that object shall NOT destroy / free the returned QueueDepth object. It is however free to modify it by adding and removing elements to it.  <a href="#af68105dcf547ca16ee8c23fb86ee7196">More...</a><br /></td></tr>
<tr class="separator:af68105dcf547ca16ee8c23fb86ee7196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea253d4290392bd0e07425698a41fe3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a6ea253d4290392bd0e07425698a41fe3">GetQueueDepthsForBpf</a> ()</td></tr>
<tr class="memdesc:a6ea253d4290392bd0e07425698a41fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the queue depths for use in the BPF algorithm. Memory ownership is transferred to the calling object. However, that object shall NOT destroy / free the returned QueueDepth object. It is however free to modify it by adding and removing elements to it.  <a href="#a6ea253d4290392bd0e07425698a41fe3">More...</a><br /></td></tr>
<tr class="separator:a6ea253d4290392bd0e07425698a41fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af735ce7a5e172a8834f9d778d2562dc9"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#af735ce7a5e172a8834f9d778d2562dc9">GetQueueDepthForProxies</a> ()</td></tr>
<tr class="memdesc:af735ce7a5e172a8834f9d778d2562dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single queue depth for this bin to be shared with the proxies for admission control.  <a href="#af735ce7a5e172a8834f9d778d2562dc9">More...</a><br /></td></tr>
<tr class="separator:af735ce7a5e172a8834f9d778d2562dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb41e3d262f16c681e2dd991fe3aef9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb41e3d262f16c681e2dd991fe3aef9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#adb41e3d262f16c681e2dd991fe3aef9e">AdjustQueueValuesForAntiStarvation</a> ()</td></tr>
<tr class="memdesc:adb41e3d262f16c681e2dd991fe3aef9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the queue depths for anti-starvation. <br /></td></tr>
<tr class="separator:adb41e3d262f16c681e2dd991fe3aef9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312fba352e9fb5b66f683e1a9f4574ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a312fba352e9fb5b66f683e1a9f4574ee">SetDefaultDropPolicy</a> (<a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> policy)</td></tr>
<tr class="memdesc:a312fba352e9fb5b66f683e1a9f4574ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default drop policy.  <a href="#a312fba352e9fb5b66f683e1a9f4574ee">More...</a><br /></td></tr>
<tr class="separator:a312fba352e9fb5b66f683e1a9f4574ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cff80a319926d4bd7894679529c698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ac7cff80a319926d4bd7894679529c698">set_drop_policy</a> (<a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> policy)</td></tr>
<tr class="memdesc:ac7cff80a319926d4bd7894679529c698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the drop policy of a specific bin.  <a href="#ac7cff80a319926d4bd7894679529c698">More...</a><br /></td></tr>
<tr class="separator:ac7cff80a319926d4bd7894679529c698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fbc57521597f10e95866ce01333fdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#af6fbc57521597f10e95866ce01333fdf">set_drop_policy</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat, <a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> policy)</td></tr>
<tr class="memdesc:af6fbc57521597f10e95866ce01333fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the drop policy of a specific bin for a specific latency.  <a href="#af6fbc57521597f10e95866ce01333fdf">More...</a><br /></td></tr>
<tr class="separator:af6fbc57521597f10e95866ce01333fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddbfa5541067e2124f619574c210398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a4ddbfa5541067e2124f619574c210398">drop_policy</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat) const </td></tr>
<tr class="memdesc:a4ddbfa5541067e2124f619574c210398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the drop policy of a specific bin for a specific latency.  <a href="#a4ddbfa5541067e2124f619574c210398">More...</a><br /></td></tr>
<tr class="separator:a4ddbfa5541067e2124f619574c210398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71186c51b21d05ffcc59a999c514034"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ac71186c51b21d05ffcc59a999c514034">drop_policy</a> () const </td></tr>
<tr class="memdesc:ac71186c51b21d05ffcc59a999c514034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the drop policy of a specific bin.  <a href="#ac71186c51b21d05ffcc59a999c514034">More...</a><br /></td></tr>
<tr class="separator:ac71186c51b21d05ffcc59a999c514034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982f34b488263d7d5b2c12bda7c66042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a982f34b488263d7d5b2c12bda7c66042">set_max_bin_depth_pkts</a> (uint32_t depth)</td></tr>
<tr class="memdesc:a982f34b488263d7d5b2c12bda7c66042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of packets allowed in a queue.  <a href="#a982f34b488263d7d5b2c12bda7c66042">More...</a><br /></td></tr>
<tr class="separator:a982f34b488263d7d5b2c12bda7c66042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a10075b3b9dd9a83e8d7b8387590e03"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a2a10075b3b9dd9a83e8d7b8387590e03">max_bin_depth_pkts</a> () const </td></tr>
<tr class="memdesc:a2a10075b3b9dd9a83e8d7b8387590e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum bin packets allowed per bin.  <a href="#a2a10075b3b9dd9a83e8d7b8387590e03">More...</a><br /></td></tr>
<tr class="separator:a2a10075b3b9dd9a83e8d7b8387590e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62349b220e89690bbe90574498de6986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a62349b220e89690bbe90574498de6986">ProcessCapacityUpdate</a> (uint32_t pc_num, double capacity_bps)</td></tr>
<tr class="memdesc:a62349b220e89690bbe90574498de6986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a capacity update from the bpf.  <a href="#a62349b220e89690bbe90574498de6986">More...</a><br /></td></tr>
<tr class="separator:a62349b220e89690bbe90574498de6986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61182295161150d74326bc6e50ade1e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a61182295161150d74326bc6e50ade1e0">SetASAPCap</a> (uint32_t new_cap, bool is_ls)</td></tr>
<tr class="memdesc:a61182295161150d74326bc6e50ade1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass a new <a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> cap on to the <a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> manager.  <a href="#a61182295161150d74326bc6e50ade1e0">More...</a><br /></td></tr>
<tr class="separator:a61182295161150d74326bc6e50ade1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe23e8984d340437432341a3058cb17b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#afe23e8984d340437432341a3058cb17b">Initialize</a> (const <a class="el" href="classiron_1_1ConfigInfo.html">ConfigInfo</a> &amp;config_info, <a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> node_bin_idx)</td></tr>
<tr class="memdesc:afe23e8984d340437432341a3058cb17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> and log configuration information.  <a href="#afe23e8984d340437432341a3058cb17b">More...</a><br /></td></tr>
<tr class="separator:afe23e8984d340437432341a3058cb17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf8008410410b2736eea3422e7f1a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#abbf8008410410b2736eea3422e7f1a6a">set_debug_stats</a> (<a class="el" href="classiron_1_1DebuggingStats.html">DebuggingStats</a> *debug_stats)</td></tr>
<tr class="memdesc:abbf8008410410b2736eea3422e7f1a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a reference to a <a class="el" href="classiron_1_1DebuggingStats.html" title="Class for maintaining statistics in memory and logging during shut down. ">DebuggingStats</a> object.  <a href="#abbf8008410410b2736eea3422e7f1a6a">More...</a><br /></td></tr>
<tr class="separator:abbf8008410410b2736eea3422e7f1a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc1f25999ee046983a6075a70a7cc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a6cdc1f25999ee046983a6075a70a7cc7">IsOrdered</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat) const </td></tr>
<tr class="memdesc:a6cdc1f25999ee046983a6075a70a7cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a packet queue is ordered.  <a href="#a6cdc1f25999ee046983a6075a70a7cc7">More...</a><br /></td></tr>
<tr class="separator:a6cdc1f25999ee046983a6075a70a7cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f45b1d6fb5e26415d110b5016248e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55f45b1d6fb5e26415d110b5016248e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a55f45b1d6fb5e26415d110b5016248e0">Print</a> ()</td></tr>
<tr class="memdesc:a55f45b1d6fb5e26415d110b5016248e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a summmary of the bin queue mgr. <br /></td></tr>
<tr class="separator:a55f45b1d6fb5e26415d110b5016248e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3bf878bb64aebcb3d390bf6ef23add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1GenXplot.html">GenXplot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a1e3bf878bb64aebcb3d390bf6ef23add">GetQueueDepthsXplot</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin_index)</td></tr>
<tr class="memdesc:a1e3bf878bb64aebcb3d390bf6ef23add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accessor for the ongoing queue depths graph.  <a href="#a1e3bf878bb64aebcb3d390bf6ef23add">More...</a><br /></td></tr>
<tr class="separator:a1e3bf878bb64aebcb3d390bf6ef23add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c6a9b06584637945def8ebde629491"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ab1c6a9b06584637945def8ebde629491">PeriodicAdjustQueueValues</a> ()</td></tr>
<tr class="memdesc:ab1c6a9b06584637945def8ebde629491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle any queue depth adjustments needed on a low-fidelity timer.  <a href="#ab1c6a9b06584637945def8ebde629491">More...</a><br /></td></tr>
<tr class="separator:ab1c6a9b06584637945def8ebde629491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e94ff70ba587257fe3975955543a50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a14e94ff70ba587257fe3975955543a50">AdjustQueueValuesOnChange</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin_idx)</td></tr>
<tr class="memdesc:a14e94ff70ba587257fe3975955543a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the destination-specific values in response to a queue depth change.  <a href="#a14e94ff70ba587257fe3975955543a50">More...</a><br /></td></tr>
<tr class="separator:a14e94ff70ba587257fe3975955543a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0ffa155095b0af4c14b2a7fa9e174f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a8a0ffa155095b0af4c14b2a7fa9e174f">AddNewZombie</a> (uint32_t dst_addr_nbo, uint32_t total_zombie_bytes, <a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> zombie_class, <a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a> dst_vec=0)</td></tr>
<tr class="memdesc:a8a0ffa155095b0af4c14b2a7fa9e174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and enqueue zombie bytes with the given specs.  <a href="#a8a0ffa155095b0af4c14b2a7fa9e174f">More...</a><br /></td></tr>
<tr class="separator:a8a0ffa155095b0af4c14b2a7fa9e174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6010679a28d8d66fc587c735917a3242"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a6010679a28d8d66fc587c735917a3242">per_dst_per_lat_class_bytes</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin, <a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat)</td></tr>
<tr class="memdesc:a6010679a28d8d66fc587c735917a3242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the queue depth in bytes for the given bin and class.  <a href="#a6010679a28d8d66fc587c735917a3242">More...</a><br /></td></tr>
<tr class="separator:a6010679a28d8d66fc587c735917a3242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4d355938b1a86c5a75e20c2a60e4b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1Time.html">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a8d4d355938b1a86c5a75e20c2a60e4b2">last_dequeue_time</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin_index)</td></tr>
<tr class="memdesc:a8d4d355938b1a86c5a75e20c2a60e4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last dequeue time for a packet for the given bin.  <a href="#a8d4d355938b1a86c5a75e20c2a60e4b2">More...</a><br /></td></tr>
<tr class="separator:a8d4d355938b1a86c5a75e20c2a60e4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae749b4705745f96e9c587e64dd924cdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae749b4705745f96e9c587e64dd924cdd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ae749b4705745f96e9c587e64dd924cdd">IsNonZombieLatClass</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat)</td></tr>
<tr class="memdesc:ae749b4705745f96e9c587e64dd924cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a latency class is a non-zombie latency class. <br /></td></tr>
<tr class="separator:ae749b4705745f96e9c587e64dd924cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329becf4e826ab4897c177d2556c93e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a329becf4e826ab4897c177d2556c93e7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a329becf4e826ab4897c177d2556c93e7">non_zombie_queue_depth_bytes</a> (<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a> bin_idx)</td></tr>
<tr class="memdesc:a329becf4e826ab4897c177d2556c93e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of non-zombie packets in the queue. <br /></td></tr>
<tr class="separator:a329becf4e826ab4897c177d2556c93e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5d422ef5eab5e8f2cdb842db3480eeae"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a5d422ef5eab5e8f2cdb842db3480eeae">IsPktlessZQueue</a> (<a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat)</td></tr>
<tr class="memdesc:a5d422ef5eab5e8f2cdb842db3480eeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue for this LatencyClass doesn't store actual packets.  <a href="#a5d422ef5eab5e8f2cdb842db3480eeae">More...</a><br /></td></tr>
<tr class="separator:a5d422ef5eab5e8f2cdb842db3480eeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad03961b7c4800d52d1455532d798986f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ad03961b7c4800d52d1455532d798986f">OnDequeue</a> (const <a class="el" href="structiron_1_1DequeuedInfo.html">DequeuedInfo</a> &amp;dq_info, bool cloned)</td></tr>
<tr class="memdesc:ad03961b7c4800d52d1455532d798986f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs any necessary cleanup and logging after a dequeue.  <a href="#ad03961b7c4800d52d1455532d798986f">More...</a><br /></td></tr>
<tr class="separator:ad03961b7c4800d52d1455532d798986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446b9812a68e3266dcae2e8e84624276"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a446b9812a68e3266dcae2e8e84624276">OnEnqueue</a> (uint32_t pkt_length_bytes, <a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> lat, <a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a> dsts)</td></tr>
<tr class="memdesc:a446b9812a68e3266dcae2e8e84624276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs any necessary cleanup and accounting after an enqueue.  <a href="#a446b9812a68e3266dcae2e8e84624276">More...</a><br /></td></tr>
<tr class="separator:a446b9812a68e3266dcae2e8e84624276"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aba75dc886baa7f51202cb77898374e35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba75dc886baa7f51202cb77898374e35"></a>
<a class="el" href="classiron_1_1PacketPool.html">PacketPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#aba75dc886baa7f51202cb77898374e35">packet_pool_</a></td></tr>
<tr class="memdesc:aba75dc886baa7f51202cb77898374e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool containing packets to use. <br /></td></tr>
<tr class="separator:aba75dc886baa7f51202cb77898374e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1508abee1a3231ba6d30e1ccfafed483"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1508abee1a3231ba6d30e1ccfafed483"></a>
<a class="el" href="classiron_1_1BinMap.html">BinMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bin_map_</b></td></tr>
<tr class="separator:a1508abee1a3231ba6d30e1ccfafed483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07abc6fd796d2d9bc01c0d06d5de8180"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07abc6fd796d2d9bc01c0d06d5de8180"></a>
<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a07abc6fd796d2d9bc01c0d06d5de8180">my_bin_index_</a></td></tr>
<tr class="memdesc:a07abc6fd796d2d9bc01c0d06d5de8180"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of this node's bin id. <br /></td></tr>
<tr class="separator:a07abc6fd796d2d9bc01c0d06d5de8180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bb6f60d9885c5e67bdeddd8d1e6249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9bb6f60d9885c5e67bdeddd8d1e6249"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#ab9bb6f60d9885c5e67bdeddd8d1e6249">initialized_</a></td></tr>
<tr class="memdesc:ab9bb6f60d9885c5e67bdeddd8d1e6249"><td class="mdescLeft">&#160;</td><td class="mdescRight">True once the initialization function has been called. <br /></td></tr>
<tr class="separator:ab9bb6f60d9885c5e67bdeddd8d1e6249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce91eca60168f1a7f415ea6c756d414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiron_1_1LatencyQueue.html">LatencyQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a6ce91eca60168f1a7f415ea6c756d414">phy_queue_</a></td></tr>
<tr class="separator:a6ce91eca60168f1a7f415ea6c756d414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98377a1889dba251e8537e405aae23be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a98377a1889dba251e8537e405aae23be">queue_depths_</a></td></tr>
<tr class="separator:a98377a1889dba251e8537e405aae23be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925c1cb556aec14b2ba8a4a28c67d45f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a925c1cb556aec14b2ba8a4a28c67d45f"></a>
<a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiron_1_1BinQueueMgr.html#a925c1cb556aec14b2ba8a4a28c67d45f">node_bin_idx_</a></td></tr>
<tr class="memdesc:a925c1cb556aec14b2ba8a4a28c67d45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node's bin index. <br /></td></tr>
<tr class="separator:a925c1cb556aec14b2ba8a4a28c67d45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> class stores and manages the queues for a. </p>
<p>There is a backpressure <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> for each node in the network for each multicast group and for each unicast destination. These BinQueueMgrs are a collection of queues (one for each traffic class) along with the stored queue depths (per destination for a multicast group) and logic to support QLAM generation, sharing depths with admission control, and managing algorithm-specific queue values used for various purposes. </p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00143">143</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af89c2870df5ec05757ab465f8c6a6335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BinQueueMgr::BinQueueMgr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>bin_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiron_1_1PacketPool.html">PacketPool</a> &amp;&#160;</td>
          <td class="paramname"><em>packet_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiron_1_1BinMap.html">BinMap</a> &amp;&#160;</td>
          <td class="paramname"><em>bin_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Defaults to using queues with a FIFO dequeueing policy with a HEAD drop policy, a limit of 500 packets per bin, and a limit of 2500 packets total across all bins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin_idx</td><td>Bin index of the unicast destination or mcast group. </td></tr>
    <tr><td class="paramname">packet_pool</td><td>Pool containing packet to use. </td></tr>
    <tr><td class="paramname">bin_map</td><td>Mapping of IRON bins. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00139">139</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8a0ffa155095b0af4c14b2a7fa9e174f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::AddNewZombie </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_addr_nbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>total_zombie_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>zombie_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a>&#160;</td>
          <td class="paramname"><em>dst_vec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and enqueue zombie bytes with the given specs. </p>
<p>This will create zombie bytes in the most efficient way possible - either by creating a packet (if we have real zombie packets for the speicifed zombie latency class) or just inserting bytes (if that class has a packetless zombie queue). If using real packets, this will create the correct number of zombies (based on the configured max zombie size) to add up to the specified byte total.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_add_nbo</td><td>The destination address of the zombies, in case we are generating real packets. </td></tr>
    <tr><td class="paramname">total_zombie_bytes</td><td>The total number of zombie bytes to be enqueued, which may be a single packet or multiple packets, depending on the configured max zombie size. </td></tr>
    <tr><td class="paramname">zombie_class</td><td>The latency class for the new zombie. Must be one of the zombie latency classes. </td></tr>
    <tr><td class="paramname">dst_vec</td><td>The destination bit vector if this is a multicast packet. 0 for unicast. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00984">984</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a14e94ff70ba587257fe3975955543a50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void iron::BinQueueMgr::AdjustQueueValuesOnChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>bin_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the destination-specific values in response to a queue depth change. </p>
<p>Base class does nothing. </p>

<p>Reimplemented in <a class="el" href="classiron_1_1EWMABinQueueMgr.html#a91763b16da6e5f9f72fa2edc3128869f">iron::EWMABinQueueMgr</a>.</p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00662">662</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a37c710f5a699adc5c81c194e44736621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::ContainsLSNonZombies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the queue contains any LS (and lower latency) packets NOT INCLUDING LS zombies. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are any LS non-zombie bytes in the queue. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01214">1214</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a76971fb3f44023c39ac7692886ced5c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::ContainsNonZombies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the queue contains any LS (and lower latency) packets NOT INCLUDING LS zombies. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are any non-zombie bytes in the queue. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01207">1207</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac0bc003cf1fa5e05543631383adee660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::ContainsPacketsWithTtypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> *&#160;</td>
          <td class="paramname"><em>ttypes_to_query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_types_to_query</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the queue contains any packets in the given set of traffic types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttypes_to_query</td><td>An array of LatencyClass values to be included in the non-zero check. </td></tr>
    <tr><td class="paramname">num_types_to_query</td><td>The number of traffic types to query, size of ttypes_to_query (no more than NUM_LATENCY_DEF).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there are any bytes in the queue with the specified traffic types. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01221">1221</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0ef5a7e11d12745b907e22077f3ae034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::CriticalizePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn a packet into a Critical packet, that is to be serviced in first traffic type queue. </p>
<p>Memory ownership goes to the queues in case of success, to the caller otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>A pointer to the packet to turn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully Criticalized, false otherwise and needs to be dropped. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01048">1048</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aacbfb6586aeb8b2d53fa6631b17493cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t BinQueueMgr::depth_packets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the depth of a bin in the queue container.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of packets in the specified bin. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01167">1167</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a22412eb4e2da5368901c13ed20ca6ac1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * BinQueueMgr::Dequeue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue a packet from a specific bin. </p>
<p>If a packet is dequeued, the caller takes ownership of the memory.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the packet dequeued. May be NULL. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00807">807</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aeb31492e730a82e8c843678e0f8a0a68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * iron::BinQueueMgr::Dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_size_bytes</em> = <code>UINT32_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a>&#160;</td>
          <td class="paramname"><em>dst_vec</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue a packet from a specific bin from a specific latency queue. </p>
<p>If a packet is dequeued, the caller takes ownership of the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue from which to dequeue. </td></tr>
    <tr><td class="paramname">max_size_bytes</td><td>The maximum size packet to be returned. </td></tr>
    <tr><td class="paramname">dst_vec</td><td>Dequeue a packet for this dst_vec. NOTE: behavior is currently unspecified when dst_vec is passed in for a non-zombie-queue latency class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the packet dequeued. May be NULL. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00912">912</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af33c388bdeb5a079e56923d714906237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * BinQueueMgr::DequeueAtCurrentIterator </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue the element at the iterator in the walk and set the iterator to the next element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the packet being dequeued of NULL if there are no packets. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00732">732</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab1dea9dc664566f890206423f7bdf30a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * BinQueueMgr::DequeueAtIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> &amp;&#160;</td>
          <td class="paramname"><em>qws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a>&#160;</td>
          <td class="paramname"><em>send_to</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue the packet placed at the iterator. Memory ownership quits the queue to go with the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency class of the packet. </td></tr>
    <tr><td class="paramname">qws</td><td>The iterator from where to dequeue. </td></tr>
    <tr><td class="paramname">send_to</td><td>The DstVec containing destinations to which to send the packet, or 0 to dequeue the entire packet (such as for unicast).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the dequeued packet, NULL if nothing found. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00839">839</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4ddbfa5541067e2124f619574c210398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> iron::BinQueueMgr::drop_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the drop policy of a specific bin for a specific latency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency-queue to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The drop policy of the bin. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01353">1353</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac71186c51b21d05ffcc59a999c514034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a> iron::BinQueueMgr::drop_policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the drop policy of a specific bin. </p>
<dl class="section return"><dt>Returns</dt><dd>The drop policy of the bin. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01347">1347</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a608582bb5110e8b2f6f8f57b5664eeab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t iron::BinQueueMgr::DropFromQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a>&#160;</td>
          <td class="paramname"><em>dst_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop bytes from the queue for the specified latency. </p>
<p>The packet or bytes selected to be dropped is determined by the drop policy configured with the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency class for which we want to drop bytes. </td></tr>
    <tr><td class="paramname">max_size_bytes</td><td>The maximum number of bytes to drop. </td></tr>
    <tr><td class="paramname">dst_vec</td><td>The destinations for which we want to drop bytes. Ignored for unicast. For non-zombie queues, this function will search until it finds a packet that matches the given dst_vec.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes dropped (may be 0) </dd></dl>

</div>
</div>
<a class="anchor" id="ad8bbe93e26e5f7631df9eb9ab0c832e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t iron::BinQueueMgr::DropFromQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_size_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop bytes from the queue for the specified latency. </p>
<p>The packet or bytes selected to be dropped is determined by the drop policy configured with the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency class for which we want to drop bytes. </td></tr>
    <tr><td class="paramname">max_size_bytes</td><td>The maximum number of bytes to drop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes dropped (may be 0) </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00279">279</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1e8faf0193b6b98d6bf85f08eb9fa03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t iron::BinQueueMgr::DropFromQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop bytes from the queue for the specified latency. </p>
<p>The packet or bytes selected to be dropped is determined by the drop policy configured with the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency class for which we want to drop bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes dropped (may be 0) </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00293">293</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9dadcb1d68a1e01dba26f45d1e959772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::Enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a packet to a bin. </p>
<p>If the specified bin does not already exist, then the bin will be added with the dequeue policy and drop policy specified in the constructor.</p>
<p>If the packet is successfully enqueued, then the bin queue mgr takes ownership of the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>A pointer to the packet to be enqueued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the packet was successfully enqueued, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00542">542</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="acb7859caf0293f9abdba8f0e43e1b25a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> BinQueueMgr::GetFrontIterator </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the queue iterator at the front of the queue to point where the dequeue should happen. This method does not require to call PrepareIteration first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator set to NULL if not found, the iterator otherwise. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00754">754</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a52e09edbb679dd122b1bb70799b18db5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::GetIterator </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> &amp;&#160;</td>
          <td class="paramname"><em>qws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the queue iterator pointing to a given packet, where the dequeue should happen. Note: This does not require calling PrepareIterator first and it walks the whole queue until it finds the packet. This method is intended to find the iterator where a packet was newly enqueued in the CRITICAL queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet. </td></tr>
    <tr><td class="paramname">pkt</td><td>The packet to match to the returned iterator. </td></tr>
    <tr><td class="paramname">qws</td><td>The iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if iterator valid, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00775">775</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8bb62c0ec935d82ae7a9fb6ee3b2ec85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a>* iron::BinQueueMgr::GetNbrQueueDepths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>nbr_bin_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the queue depths for a neighbor bin index for this unicast or multicast destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbr_bin_idx</td><td>The neighbor bin index whose queue depth we want. May be a unicast destination or interior node bin index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object containing the bin identifiers and their respective depths in number of packets. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00465">465</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91f2f7816816f8fee51e03575f3bf696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BinQueueMgr::GetNextDequeueSize </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the potential size of the next packet for this bin and latency class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The potential size of the next packet to be dequeued. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00665">665</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a438b0a1528e9d45812133caf314bf956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BinQueueMgr::GetNextDequeueSize </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>bin_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the potential size of the next packet for this bin and latency class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet size. </td></tr>
    <tr><td class="paramname">bin_index</td><td>For use with multicast bins: this is the destination for which we want the next dequeue size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The potential size of the next packet to be dequeued. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00680">680</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af735ce7a5e172a8834f9d778d2562dc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t BinQueueMgr::GetQueueDepthForProxies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the single queue depth for this bin to be shared with the proxies for admission control. </p>
<dl class="section return"><dt>Returns</dt><dd>The value to be passed to the proxies for admission control. </dd></dl>

<p>Reimplemented in <a class="el" href="classiron_1_1EWMABinQueueMgr.html#a6188e1deafaf176fa326ce8d8eca72a4">iron::EWMABinQueueMgr</a>, <a class="el" href="classiron_1_1HvyballBinQueueMgr.html#a496df0d18b8ddea7371cfec8d66ea0b5">iron::HvyballBinQueueMgr</a>, and <a class="el" href="classiron_1_1NPLBBinQueueMgr.html#ab74fbea1c4ca32b164023bc088aad6d9">iron::NPLBBinQueueMgr</a>.</p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00513">513</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a93ffb9dc591bb4c0438155baabf7cefe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a>* iron::BinQueueMgr::GetQueueDepths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the depths of all bins. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object containing the bin identifiers and their respective depths in number of packets. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00451">451</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6ea253d4290392bd0e07425698a41fe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a>* iron::BinQueueMgr::GetQueueDepthsForBpf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the queue depths for use in the BPF algorithm. Memory ownership is transferred to the calling object. However, that object shall NOT destroy / free the returned QueueDepth object. It is however free to modify it by adding and removing elements to it. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the queue depths object for use in BPF. </dd></dl>

<p>Reimplemented in <a class="el" href="classiron_1_1EWMABinQueueMgr.html#a68ab3bd3abafa2a0636c2a7730a87ccb">iron::EWMABinQueueMgr</a>, <a class="el" href="classiron_1_1HvyballBinQueueMgr.html#aa40fb7523f93b82b3a0d6eae8b03557a">iron::HvyballBinQueueMgr</a>, and <a class="el" href="classiron_1_1NPLBBinQueueMgr.html#a166038e25a33ba340af6df7ec28bef79">iron::NPLBBinQueueMgr</a>.</p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00499">499</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="af68105dcf547ca16ee8c23fb86ee7196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a>* iron::BinQueueMgr::GetQueueDepthsForBpfQlam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the queue depths to be used to generate a QLAM to BPF. Memory ownership is transferred to the calling object. However, that object shall NOT destroy / free the returned QueueDepth object. It is however free to modify it by adding and removing elements to it. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the queue depths object to be used in QLAM. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00486">486</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1e3bf878bb64aebcb3d390bf6ef23add"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1GenXplot.html">GenXplot</a>* iron::BinQueueMgr::GetQueueDepthsXplot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>bin_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the accessor for the ongoing queue depths graph. </p>
<p>This will allow other classes to help write to the graph. This will return NULL if we aren't configured to generate these graphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin_index</td><td>Which unicast or multicast bin index for the graph we want to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the utility object for writing to the graph, or NULL if we weren't configured to generate these. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00640">640</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a756a25a969220ab960585aec66ee1e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t BinQueueMgr::GetTotalDequeueSize </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total size of the bytes for this bin and latency class available for dequeue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum size of the next packet to be dequeued. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00650">650</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a76b257049f26dfdeb36c173c9b2249cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t BinQueueMgr::GetTtypeDepthBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>dst_to_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a> *&#160;</td>
          <td class="paramname"><em>ttypes_to_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num_ttypes_to_get</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of bytes enqueued in a set of latency queues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_to_get</td><td>Destination bin index for which we want the depth. </td></tr>
    <tr><td class="paramname">ttypes_to_get</td><td>An array of LatencyClass values to be included in the returned total. </td></tr>
    <tr><td class="paramname">num_types_to_get</td><td>The number of traffic types to get, size of ttypes_to_get (no more than NUM_LATENCY_DEF).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (virtual) queue depth in bytes. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01237">1237</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afe23e8984d340437432341a3058cb17b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiron_1_1ConfigInfo.html">ConfigInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>config_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>node_bin_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> and log configuration information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_info</td><td>The reference to the config info object used to initialize values. </td></tr>
    <tr><td class="paramname">node_bin_idx</td><td>The node's bin index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization succeeded. </dd></dl>

<p>Reimplemented in <a class="el" href="classiron_1_1EWMABinQueueMgr.html#a96397bccf9a7bf511dc6784a29c8cc3b">iron::EWMABinQueueMgr</a>, <a class="el" href="classiron_1_1HvyballBinQueueMgr.html#a8e5f87f5daf99f593170a01339afbd01">iron::HvyballBinQueueMgr</a>, and <a class="el" href="classiron_1_1NPLBBinQueueMgr.html#aa954df9de136c765d5caf3aaff6bfd98">iron::NPLBBinQueueMgr</a>.</p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00193">193</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a682704689225d39a44f4d13259ef2ba6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iron::BinQueueMgr::is_multicast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the bin queue mgr is associated with a multicast destination. </p>
<dl class="section return"><dt>Returns</dt><dd>true for multicast, false for unicast. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00205">205</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6cdc1f25999ee046983a6075a70a7cc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::IsOrdered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a packet queue is ordered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if ordered, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01123">1123</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5d422ef5eab5e8f2cdb842db3480eeae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::IsPktlessZQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the queue for this LatencyClass doesn't store actual packets. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the given LatencyClass uses a zombie queue (without real packets), or false if it uses a queue of packets. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00507">507</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8d4d355938b1a86c5a75e20c2a60e4b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Time.html">Time</a> iron::BinQueueMgr::last_dequeue_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>bin_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last dequeue time for a packet for the given bin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin_index</td><td>The bin index of the target destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classiron_1_1Time.html">Time</a> The last time a packet was dequeued with this destination in its dst_vec. Or the last time a packet with this destination was enqueued in an empty queue. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00711">711</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2a10075b3b9dd9a83e8d7b8387590e03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t iron::BinQueueMgr::max_bin_depth_pkts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum bin packets allowed per bin. </p>
<p>Note that this is the limit of the queues and not the size of the largest queue.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of packets allowed in a bin in the <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a> </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00581">581</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad03961b7c4800d52d1455532d798986f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::OnDequeue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structiron_1_1DequeuedInfo.html">DequeuedInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dq_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs any necessary cleanup and logging after a dequeue. </p>
<p>This function is useful because we have several dequeue functions that all need the same follow-on work after successfully finding a packet, and because subclasses have algorithm-specific actions after a dequeue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq_info</td><td>Information about the packet (or bytes) that was dequeued. </td></tr>
    <tr><td class="paramname">cloned</td><td>True if the "dequeue" was a packet clone, leaving the original packet behind in the queue to send to other destinations. False if we removed the entire packet. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classiron_1_1HvyballBinQueueMgr.html#a850813a6d79da24afb142f54043afabf">iron::HvyballBinQueueMgr</a>, and <a class="el" href="classiron_1_1NPLBBinQueueMgr.html#ac3a18660c3a783cee6ff313bab42a401">iron::NPLBBinQueueMgr</a>.</p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01393">1393</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a446b9812a68e3266dcae2e8e84624276"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::OnEnqueue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pkt_length_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#aacbb07180f64325df5439a0fcc7dae80">DstVec</a>&#160;</td>
          <td class="paramname"><em>dsts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs any necessary cleanup and accounting after an enqueue. </p>
<p>This function is useful because subclasses have algorithm-specific actions after an enqueue. Params are properties of the packet, rather than the packet itself, for the sake of thread-safety (assuming we've given up ownership of the packet as soon as it enters the queue).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt_length_bytes</td><td>Length of the enqueued packet (or virtual length, for zombies) </td></tr>
    <tr><td class="paramname">lat</td><td>Latency class of the enqueued packet </td></tr>
    <tr><td class="paramname">dsts</td><td>Destination bit vector for multicast </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classiron_1_1HvyballBinQueueMgr.html#a3c4be13fcf211b6dad492481fa78ca64">iron::HvyballBinQueueMgr</a>.</p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01368">1368</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af3d1b338ee73237329b8353510b30a69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * BinQueueMgr::Peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek at the next packet from a specific bin looking from low to high latency. </p>
<p>Memory ownership of the packet stays with the queue! The caller SHOULD NOT free the packet.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the packet peeked. May be NULL. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00617">617</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="acd810c389fd0e0ac9966658bf8335fb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * BinQueueMgr::Peek </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek at the next packet from a specific bin for a specific latency queue. </p>
<p>Memory ownership of the packet stays with the queue! The caller SHOULD NOT free the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the packet peeked. May be NULL. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00636">636</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3ec8d5fb64aaa8028adcee04114d497b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1Packet.html">Packet</a> * BinQueueMgr::PeekNext </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structiron_1_1PacketQueue_1_1QueueWalkState.html">PacketQueue::QueueWalkState</a> &amp;&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek the next element during a walk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet. </td></tr>
    <tr><td class="paramname">ws</td><td>The iterator where the packet was found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the packet being peeked or NULL if there are no packets to peek. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00695">695</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6010679a28d8d66fc587c735917a3242"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t iron::BinQueueMgr::per_dst_per_lat_class_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the queue depth in bytes for the given bin and class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin</td><td>The bin index for which to return the depth. </td></tr>
    <tr><td class="paramname">lat</td><td>The latency class for which to return the depth.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t The appropriate queue depth. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00698">698</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1c6a9b06584637945def8ebde629491"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::PeriodicAdjustQueueValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle any queue depth adjustments needed on a low-fidelity timer. </p>
<p>Used to handle anti-starvation and by subclasses to manage other queue depth adjustements.</p>
<p>For the base class, this just triggers anti-starvation adjustments.</p>
<p>This will be called at least once per BPF select loop. Timing is handled internally within the function so that different queue depth managers can act at different time scales. </p>

<p>Reimplemented in <a class="el" href="classiron_1_1HvyballBinQueueMgr.html#a4f57d133d03fbc80bb7e89b2698cef86">iron::HvyballBinQueueMgr</a>, and <a class="el" href="classiron_1_1EWMABinQueueMgr.html#a0d0debbc54c7154d5b9e049787f95729">iron::EWMABinQueueMgr</a>.</p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01255">1255</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af40d4385a5512bcc2fb04323862e5cf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::PrepareIteration </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare an iterator to the queue, starting from the back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency queue where to peek for the next packet.</td></tr>
  </table>
  </dd>
</dl>
<p>This method MUST BE CALLED before any exploration of the queue. Sequence: PrepareIteration, PeekNext, DequeueAtCurrentIterator. </p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00792">792</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a62349b220e89690bbe90574498de6986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::ProcessCapacityUpdate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pc_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>capacity_bps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process a capacity update from the bpf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pc_num</td><td>The path controller number</td></tr>
    <tr><td class="paramname">capacity_bps</td><td>The current capacity estimate in bps </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01268">1268</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abbf8008410410b2736eea3422e7f1a6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iron::BinQueueMgr::set_debug_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiron_1_1DebuggingStats.html">DebuggingStats</a> *&#160;</td>
          <td class="paramname"><em>debug_stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a reference to a <a class="el" href="classiron_1_1DebuggingStats.html" title="Class for maintaining statistics in memory and logging during shut down. ">DebuggingStats</a> object. </p>
<p>This will allow code in <a class="el" href="classiron_1_1QueueStore.html" title="Container class for Queues and Queue Value Management for all multicast groups and destinations and f...">QueueStore</a> to track values over time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debug_stats</td><td>Pointer to existing <a class="el" href="classiron_1_1DebuggingStats.html" title="Class for maintaining statistics in memory and logging during shut down. ">DebuggingStats</a> instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00615">615</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac7cff80a319926d4bd7894679529c698"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::set_drop_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the drop policy of a specific bin. </p>
<p>The drop policy should be set in the constructor and not per-bin using this method. This method is really only intended for unit tests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The desired drop policy for the bin. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01286">1286</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af6fbc57521597f10e95866ce01333fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::set_drop_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a2603a9d5ad80707c1a0aa907c23833ad">LatencyClass</a>&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the drop policy of a specific bin for a specific latency. </p>
<p>The drop policy should be set in the constructor and not per-bin using this method. This method is really only intended for unit tests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>The latency-queue to change. </td></tr>
    <tr><td class="paramname">policy</td><td>The desired drop policy for the bin. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01311">1311</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a982f34b488263d7d5b2c12bda7c66042"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iron::BinQueueMgr::set_max_bin_depth_pkts </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of packets allowed in a queue. </p>
<p>Note that this value applies to each queue in each bin. So the actual max queue depth (in packets) will be this depth for each of the latency-class-specific queues.</p>
<p><a class="el" href="classiron_1_1BinQueueMgr.html#afe23e8984d340437432341a3058cb17b" title="Set up BinQueueMgr and log configuration information. ">BinQueueMgr::Initialize</a> MUST be called after this function for the change to be picked up. This will free all existing queues (if any) and reinitialize them with the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>The maximum number of packets in a queue in the <a class="el" href="classiron_1_1BinQueueMgr.html" title="The BinQueueMgr class stores and manages the queues for a. ">BinQueueMgr</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00569">569</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a571700557f88bb432c5f263aea59cc20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::set_nbr_queue_depths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a9a5f420ded2cbb0ebfaf30509e0ce1d5">BinIndex</a>&#160;</td>
          <td class="paramname"><em>nbr_bin_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a> *&#160;</td>
          <td class="paramname"><em>qd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the queue depth object for a given neighbor bin index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbr_bin_idx</td><td>The neighbor's bin index to which the queue depth object relates. May be a unicast destination or interior node bin index. </td></tr>
    <tr><td class="paramname">qd</td><td>The queue depth object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01185">1185</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aed49d2293e9f97ceb86b16a5a45c6bda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iron::BinQueueMgr::set_support_ef </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set support for EF-traffic (enqueue in EF queues). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">support</td><td>True to set EF support, false not to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00164">164</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a61182295161150d74326bc6e50ade1e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinQueueMgr::SetASAPCap </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>new_cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_ls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass a new <a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> cap on to the <a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>The updated cap on <a class="el" href="classiron_1_1ASAP.html" title="The ASAP class contains the state and logic for the ASAP algorithm. ">ASAP</a> zombies for this bin. </td></tr>
    <tr><td class="paramname">is_ls</td><td>True if this is for latency sensitive traffic. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l01277">1277</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a312fba352e9fb5b66f683e1a9f4574ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iron::BinQueueMgr::SetDefaultDropPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceiron.html#a7decbb5442a2d1e11bba19f4d4f6640d">DropPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the default drop policy. </p>
<p>Should be called before any bins are added or any packets are enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The desired default drop policy for all bins. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00521">521</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1bcb58d3070da0405111efe0770e5d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinQueueMgr::ZombifyPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiron_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>pkt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn a packet into a <a class="el" href="classiron_1_1Zombie.html" title="Class of static utility functions for creating zombie packets. ">Zombie</a> packet, that is serviced in last latency queue. </p>
<p>Memory ownership goes to the queues in case of success, to the caller otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkt</td><td>A pointer to the packet to turn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully Zombified, false otherwise and needs to be dropped. </dd></dl>

<p>Definition at line <a class="el" href="bin__queue__mgr_8cc_source.html#l00933">933</a> of file <a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6ce91eca60168f1a7f415ea6c756d414"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiron_1_1LatencyQueue.html">LatencyQueue</a> iron::BinQueueMgr::phy_queue_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set of latency queues for this destination or multicast group. The <a class="el" href="structiron_1_1LatencyQueue.html">LatencyQueue</a> object includes an array of pointers to per-latency queues. </p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00770">770</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a98377a1889dba251e8537e405aae23be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiron_1_1QueueDepths.html">QueueDepths</a> iron::BinQueueMgr::queue_depths_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The QueueDepth object for this Unicast Bin or Multicast Bins. This is an array of per-ID queue depths. For for a unicast bin, the only value that is used in the BinIndex for this bin. For multicast, the BinIndicies of the destinations for the group are used and the other values are always 0. </p>

<p>Definition at line <a class="el" href="bin__queue__mgr_8h_source.html#l00777">777</a> of file <a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/szabele/github/IRON/iron/bpf/src/<a class="el" href="bin__queue__mgr_8h_source.html">bin_queue_mgr.h</a></li>
<li>/home/szabele/github/IRON/iron/bpf/src/<a class="el" href="bin__queue__mgr_8cc_source.html">bin_queue_mgr.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceiron.html">iron</a></li><li class="navelem"><a class="el" href="classiron_1_1BinQueueMgr.html">BinQueueMgr</a></li>
    <li class="footer">Generated on Fri Feb 26 2021 11:31:59 for IRON by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
