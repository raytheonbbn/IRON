// IRON: iron_headers
/*
 * Distribution A
 *
 * Approved for Public Release, Distribution Unlimited
 *
 * EdgeCT (IRON) Software Contract No.: HR0011-15-C-0097
 * DCOMP (GNAT)  Software Contract No.: HR0011-17-C-0050
 * Copyright (c) 2015-20 Raytheon BBN Technologies Corp.
 *
 * This material is based upon work supported by the Defense Advanced
 * Research Projects Agency under Contracts No. HR0011-15-C-0097 and
 * HR0011-17-C-0050. Any opinions, findings and conclusions or
 * recommendations expressed in this material are those of the author(s)
 * and do not necessarily reflect the views of the Defense Advanced
 * Research Project Agency.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/* IRON: end */

#include "admission_controller.h"
#include "decoding_state.h"
#include "fec_state.h"
#include "ipv4_endpoint.h"
#include "log.h"
#include "log_admission_controller.h"
#include "packet_pool.h"
#include "release_controller.h"
#include "strap_admission_controller.h"
#include "string_utils.h"
#include "throttled_release_controller.h"
#include "trap_admission_controller.h"
#include "unthrottled_release_controller.h"
#include "unused.h"
#include "udp_proxy.h"
#include "utility_fn_if.h"
#include "vdmfec.h"

#include <ctime>
#include <limits>

#include <errno.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

using ::iron::BinId;
using ::iron::BinIndex;
using ::iron::FlowState;
using ::iron::Ipv4Endpoint;
using ::iron::KVal;
using ::iron::Packet;
using ::iron::PacketPool;
using ::iron::QueueDepths;
using ::iron::FourTuple;
using ::iron::StringUtils;
using ::iron::Time;
using ::rapidjson::StringBuffer;
using ::rapidjson::Writer;
using ::std::map;
using ::std::numeric_limits;
using ::std::string;

namespace
{
  /// Class name for logging.
  const char  kClassName[] = "DecodingState";

  /// The minimum interval between event-driven RRMs generated by a flow,
  /// in milliseconds.
  const uint32_t  kMinEventRrmIntervalMsec = 1000;
}

//============================================================================
DecodingState::DecodingState(UdpProxy& udp_proxy,
                             iron::PacketPool& packet_pool,
                             iron::BinMap& bin_map,
                             iron::KVal& k_val, FecStatePool& fecstate_pool,
                             const iron::FourTuple& four_tuple,
                             uint32_t flow_tag)
    : udp_proxy_(udp_proxy),
      release_controller_(NULL),
      packet_pool_(packet_pool),
      bin_map_(bin_map),
      fecstate_pool_(fecstate_pool),
      fec_state_map_(),
      fec_grp_ready_time_(Time::Infinite()),
      next_grp_id_(-1),
      last_time_(Time::GetNowInSec()),
      max_reorder_time_(Time(0)),
      bin_idx_(iron::kInvalidBinIndex),
      four_tuple_(four_tuple),
      flow_tag_(flow_tag),
      dump_byte_number_(0),
      dump_pkt_number_(0),
      total_byte_number_(0),
      total_pkt_number_(0),
      max_pkt_delay_(Time(0)),
      cum_pkt_delay_(Time(0)),
      last_report_time_(Time::Now()),
      priority_(0),
      loss_thresh_pct_(100),
      pkt_seq_num_(0)
{
}

//============================================================================
DecodingState::~DecodingState()
{
  // Destroy the release controller.
  if (release_controller_ != NULL)
  {
    delete release_controller_;
    release_controller_ = NULL;
  }

  // Destroy the FEC State map. Recycle the FEC State objects in this map.
  if (fec_state_map_.size() != 0)
  {
    map<int, FecState*>::iterator  it;
    for (it = fec_state_map_.begin(); it != fec_state_map_.end(); ++it)
    {
      if (it->second)
      {
        fecstate_pool_.Recycle(it->second);
        it->second = NULL;
      }
    }
    fec_state_map_.clear();
  }
}

//============================================================================
bool DecodingState::CreateReleaseController(const string utility_def)
{
  // First, get the utility function type for the flow.
  size_t  type_str_pos = utility_def.find("type=");
  if (type_str_pos == string::npos)
  {
    LogF(kClassName, __func__, "fid: %" PRIu32 ", invalid utility "
         "definition.\n", flow_tag_);
    return false;
  }

  size_t  type_str_end_pos = utility_def.find(":", type_str_pos);
  if (type_str_end_pos == string::npos)
  {
    LogF(kClassName, __func__, "fid: %" PRIu32 ", invalid utility "
         "definition.\n", flow_tag_);
    return false;
  }

  string  utility_def_type = utility_def.substr(type_str_pos + 5,
                                                type_str_end_pos - 5);

  if (release_controller_ != NULL)
  {
    delete release_controller_;
    release_controller_ = NULL;
  }

  // Create the appropriate packet release controller.
  if ((utility_def_type == "TRAP") || (utility_def_type == "STRAP") ||
      (utility_def_type == "FLOG"))
  {
    LogC(kClassName, __func__, "fid: %" PRIu32 ", Creating "
         "ThrottledReleaseControl.\n", flow_tag_);
    release_controller_ = new (std::nothrow)
      ThrottledReleaseController(*this, packet_pool_);
  }
  else
  {
    LogC(kClassName, __func__, "fid: %" PRIu32 ", Creating "
         "UnthrottledReleaseControl.\n", flow_tag_);
    release_controller_ = new (std::nothrow)
      UnthrottledReleaseController(*this);
  }

  if (release_controller_ == NULL)
  {
    LogF(kClassName, __func__, "fid: %" PRIu32 ", error allocating decoding "
         "state packet release controller.\n", flow_tag_);
    return false;
  }

  return true;
}

//============================================================================
void DecodingState::HandlePkt(Packet* pkt)
{
  // Remove the FEC control trailer.
  FECControlTrailer  fecTrlr;
  memset(&fecTrlr, 0, sizeof(FECControlTrailer));

  if (!pkt->RemoveBlockFromEnd((unsigned char*)&fecTrlr, sizeof(fecTrlr)))
  {
    LogE(kClassName, __func__, "Failed to remove FEC control trailer from "
         "packet\n");
    TRACK_UNEXPECTED_DROP(kClassName, packet_pool_);
    packet_pool_.Recycle(pkt);
    return;
  }

  BinId     pkt_bin_id           = pkt->bin_id();
  BinIndex  pkt_bin_idx          = bin_map_.GetPhyBinIndex(pkt_bin_id);

  // Check the bin id to make sure that it is valid.
  if (pkt_bin_idx == iron::kInvalidBinIndex)
  {
    LogE(kClassName, __func__, "Attempting to handle a packet without a "
         "source bin id, which will not work with the decoding state.\n");
    TRACK_UNEXPECTED_DROP(kClassName, packet_pool_);
    packet_pool_.Recycle(pkt);
    return;
  }

  uint64_t  pkt_total_bytes_sent = fecTrlr.get_total_bytes_sent();
  uint32_t  pkt_seq_num          = fecTrlr.get_seq_number();
  uint8_t   pkt_priority         = fecTrlr.priority;
  uint8_t   pkt_loss_thresh      = fecTrlr.loss_thresh;
  Time      pkt_reorder_time     =
              Time(static_cast<double>(fecTrlr.reorder_time_ms) / 1000);
  int32_t   pkt_delay_ms         = 0;

#ifdef LAT_MEASURE
  struct timeval now_tval;
  gettimeofday(&now_tval, 0);

  Time      now(now_tval);
  uint16_t  now_ms  = now.GetTimeInMsec() & 0x7FFF;
  
  if (now_ms < pkt->origin_ts_ms())
  {
    // The origin timestamp wrapped. It is a 15 bit number, so we add
    // 0x7FFF to the difference.
    pkt_delay_ms += 0x7FFF + now_ms - pkt->origin_ts_ms();
  }
  else
  { 
    pkt_delay_ms      = now_ms - pkt->origin_ts_ms();
  }

  LogD(kClassName, __func__, "fid: %" PRIu32 ", got FEC pkt %s with sn %" PRIu32
       ", bytes sent: %" PRIu64 "B, ttg: %s, delay: %" PRId32 "ms, "
       "priority: %" PRIu8 ", loss threshold: %" PRIu8 "\%, reorder time: %"
       PRId64 "ms.\n",
       flow_tag_,
       pkt->GetPacketMetadataString().c_str(),
       pkt_seq_num, pkt_total_bytes_sent, pkt->GetTimeToGo().ToString().c_str(),
       pkt_delay_ms,
       pkt_priority, pkt_loss_thresh, pkt_reorder_time.GetTimeInMsec());
#else
  Time  now = Time::Now();
  

  LogD(kClassName, __func__, "fid: %" PRIu32 ", got FEC pkt %s with sn %" PRIu32
       ", bytes sent: %" PRIu64 " bytes, ttg: %s, priority: %" PRIu8
       ", loss threshold: %" PRIu8 "\%, reorder time: %" PRId64 "ms.\n",
       flow_tag_,
       pkt->GetPacketMetadataString().c_str(),
       pkt_seq_num, pkt_total_bytes_sent, pkt->GetTimeToGo().ToString().c_str(),
       pkt_priority, pkt_loss_thresh, pkt_reorder_time.GetTimeInMsec());
#endif

  last_time_ = now.GetTimeInSec();

  UdpProxy::ReleaseRecord*  release_record = NULL;
  if (max_reorder_time_.GetTimeInUsec() > 0)
  {
    udp_proxy_.GetReleaseRecord(pkt_bin_idx, four_tuple_, release_record);

    if (release_record == NULL)
    {
      LogD(kClassName, __func__, "fid: %" PRIu32 ", creating ReleaseRecord "
           "for flow %s for src bin %" PRIBinId ", total num bytes sent %"
           PRIu32 "bytes, SeqNum: %" PRIu32".\n", flow_tag_,
           four_tuple_.ToString().c_str(), pkt_bin_id, pkt_total_bytes_sent,
           pkt_seq_num);
      // TODO: Delete
      // TODO: Delete upon flush?
      if (!udp_proxy_.CreateReleaseRecord(pkt_bin_idx, four_tuple_,
                                          pkt_total_bytes_sent, pkt_seq_num,
                                          pkt_priority))
      {
        LogW(kClassName, __func__, "fid: %" PRIu32 ", error creating "
             "ReleaseRecord for flow %s.\n", flow_tag_,
             four_tuple_.ToString().c_str());
      }
    }
  }

  // Check if the priority and the loss threshold needs updating.
  if (pkt_seq_num_ < pkt_seq_num)
  {
    pkt_seq_num_ = pkt_seq_num;
    if (pkt_priority != priority_)
    {
      priority_ = pkt_priority;
      if (release_record != NULL)
      {
        release_record->HandlePriorityChange(priority_);
      }
    }
    if (pkt_loss_thresh != loss_thresh_pct_)
    {
      loss_thresh_pct_ = pkt_loss_thresh;
    }
    if (pkt_reorder_time != max_reorder_time_)
    {
      max_reorder_time_ = pkt_reorder_time;
    }
  }

  AccumulatePacketInfo(pkt->GetLengthInBytes(), Time::FromMsec(pkt_delay_ms));

  // In the case of the very first packet we must set the next group_id
  if (next_grp_id_ == -1)
  {
    next_grp_id_ = fecTrlr.group_id;

    // and the source bin_idx.
    bin_idx_ = pkt_bin_idx;
  }

  // First see if we have any clean up work to do this happens when the
  // group_id changes in ways we are not expecting, primarily due to dropped
  // packets.
  //
  // Check to see if this is a late arriving packet
  if (IsLate(fecTrlr.group_id))
  {
    if (max_reorder_time_.GetTimeInUsec() > 0)
    {
      LogW(kClassName, __func__, "fid: %" PRIu32 ", pktcount: Late pkt "
           "group: %" PRIu32 ", slot: %" PRIu32 " %s.\n", flow_tag_,
           fecTrlr.group_id, fecTrlr.slot_id,
           pkt->GetPacketMetadataString().c_str());
    }

    // We have a late packet. Since we have already moved on we don't put it
    // in cache. If the order flag is not set, there is no harm in sending it
    // as long as it is complete (i.e., not chunked). If the order flag IS
    // set, we can only discard it
    if (!fecTrlr.in_order)
    {
      if (fecTrlr.type == FEC_ORIGINAL)
      {
        // We also need to make sure that this is a self-contained packet --
        // i.e., there is only one chunk *OR* this is a blob (i.e., it
        // contains multiple smaller packets)
        FECChunkTrailer  chunkTrlr;
        if (!pkt->RemoveBlockFromEnd((uint8_t*)&chunkTrlr,
                                      sizeof(chunkTrlr)))
        {
          LogE(kClassName, __func__, "fid: %" PRIu32 ", Failed to remove "
               "chunk trailer, recycling packet.\n", flow_tag_);
          TRACK_UNEXPECTED_DROP(kClassName, packet_pool_);
          packet_pool_.Recycle(pkt);
          return;
        }

        if ((chunkTrlr.n_chunks == 1) || (chunkTrlr.is_blob  == 1))
        {
          LogD(kClassName, __func__, "fid: %" PRIu32 ", SEND: UDP proxy to "
               "LAN IF late packet %s (groupdID %d, slotID " "%d)\n", flow_tag_,
               pkt->GetPacketMetadataString().c_str(),
               fecTrlr.group_id, fecTrlr.slot_id);

          // If we have a blob, we need to pull it apart
          if (chunkTrlr.is_blob)
          {
            unsigned short  pktlen;
            unsigned char*  pdata;

            pdata  = pkt->GetBuffer();
            pdata += pkt->GetIpPayloadOffset();

            for (int i = 0; i < chunkTrlr.n_chunks; i++)
            {
              memcpy((void*)&pktlen, pdata, sizeof(pktlen));
              pdata += sizeof(pktlen);

              Packet*  rpkt = packet_pool_.CloneHeaderOnly(
                pkt, iron::PACKET_NO_TIMESTAMP);
              if (!rpkt)
              {
                LogE(kClassName, __func__, "fid: %" PRIu32 ", Received "
                     "packet cannot be cloned.\n", flow_tag_);
                return;
              }
              else
              {
                rpkt->AppendBlockToEnd(pdata, pktlen);
                rpkt->UpdateChecksums();

                size_t  bytes_sent = ReleasePkt(pkt);
                if (bytes_sent == 0)
                {
                  packet_pool_.Recycle(pkt);
                  return;
                }
                pdata += pktlen;
              }
            }
            packet_pool_.Recycle(pkt);
          }
          else
          {
            // Otherwise, we can just update the checksums and send it.
	    // TESTING: checksum shouldn't need to be updated if not a blob
            pkt->UpdateChecksums();
            size_t  bytes_sent = ReleasePkt(pkt);
            if (bytes_sent == 0)
            {
              packet_pool_.Recycle(pkt);
              return;
            }
          }
        }
      }
      else
      {
        LogD(kClassName, __func__, "fid: %" PRIu32 ", Discarding late repair "
             "packet (group_id %d, slotID %d)\n", flow_tag_, fecTrlr.group_id,
             fecTrlr.slot_id);
        TRACK_EXPECTED_DROP(kClassName, packet_pool_);
        packet_pool_.Recycle(pkt);
      }
    }
    else
    {
      packet_pool_.Recycle(pkt);
    }

    // Make sure to skip over the remainder of the transmit processing - there
    // is nothing more to do.
    return;
  }

  LogD(kClassName, __func__, "fid: %" PRIu32 ", Processing packet for group "
       "%d\n", flow_tag_, fecTrlr.group_id);

  // Get/create the FecState for this group Id.
  FecState*  fec_state = NULL;
  if (HasFecState(fecTrlr.group_id))
  {
    GetFecState(fecTrlr.group_id, fec_state);
  }
  else
  {
    fec_state = fecstate_pool_.Get();
    fec_state_map_[fecTrlr.group_id] = fec_state;
    fec_state->set_group_id(fecTrlr.group_id);
    fec_state->set_decoding_state(this);
  }

  // Add the packet we just received to the cache of the appropriate FecState.
  //
  // The operation of adding the packet to the FECState hands off ownership of
  // the packet to the FECState. We need to extract everything required from
  // the packet prior to adding it to the cache so that the values can be used
  // following a successful addition to the cache.
  Time              ttg           = pkt->GetTimeToGo();
  bool              pkt_ttg_valid = pkt->time_to_go_valid();
  Time              pkt_rcv_time  = pkt->recv_time();
  FECRepairTrailer  rep_trlr;
  if (fecTrlr.type == FEC_REPAIR)
  {
    // If its a repair packet save the encoding rate for this group Note that
    // we don't remove the block at this point because we need the FECed
    // length embedded in the repair header for the FEC processing.
    memset(&rep_trlr, 0, sizeof(FECRepairTrailer));
    pkt->CopyBlockFromEnd((unsigned char*)&rep_trlr, sizeof(rep_trlr));
  }

  if (fec_state->AddToCache(fecTrlr.type, pkt, fecTrlr.slot_id,
                            fecTrlr.fec_used, fecTrlr.total_bytes_sent,
                            fecTrlr.seq_number) != FECSTATE_OKAY)
  {
    LogW(kClassName, __func__, "fid: %" PRIu32 ", Failed to add pkt of len "
         "%d with group_id of %d and type %d to cache at slot %d\n", flow_tag_,
         pkt->GetLengthInBytes(), fecTrlr.group_id, fecTrlr.type,
         fecTrlr.slot_id);
    TRACK_UNEXPECTED_DROP(kClassName, packet_pool_);
    packet_pool_.Recycle(pkt);
    return;
  }

  // Get the expiration time of this packet.
  Time pkt_exp_time = Time::Infinite();
  if (pkt_ttg_valid && (ttg < max_reorder_time_))
  {
    pkt_exp_time = ttg + pkt_rcv_time;
  }
  else
  {
    pkt_exp_time = pkt_rcv_time + max_reorder_time_;
  }

  // Make adjustments to ensure this expires before higher numbered packets in
  // this group or the next group to expire. However, This can only lower the
  // packet expiration time, so only do it if the packet has not already
  // expired.
  if (pkt_exp_time > Time::Now())
  {
    Time next_pkt_exp = GetNextExpTime(fecTrlr.slot_id, fecTrlr.group_id);
    if (pkt_exp_time > next_pkt_exp)
    {
      pkt_exp_time  = next_pkt_exp;
    }
  }

  /// Update the minimum for all FECStates,
  if (fec_grp_ready_time_ > pkt_exp_time)
  {
    fec_grp_ready_time_ = pkt_exp_time;
  }

  /// and update the minimum for this FECState.
  fec_state->set_pkt_expiration_time(fecTrlr.slot_id, pkt_exp_time);

  if (fecTrlr.type == FEC_REPAIR)
  {
    fec_state->setRates(rep_trlr.base_rate, rep_trlr.fec_rate);
  }
}

//============================================================================
void DecodingState::SvcEvents(Time& now)
{
  LogD(kClassName, __func__, "fid: %" PRIu32 ", servicing events.\n",
       flow_tag_);

  if (fec_grp_ready_time_ <= now)
  {
    FecGrpReadyTimeout(now);
  }

  // Service all events that have expired.
  if (release_controller_ != NULL)
  {
    release_controller_->SvcEvents(now);
  }
}

//============================================================================
ssize_t DecodingState::ReleasePkt(Packet* pkt) const
{
  return udp_proxy_.SendToLan(pkt);
}

//============================================================================
void DecodingState::WriteStats(Time& now, string& log_str,
                               Writer<StringBuffer>* writer)
{
  // The collected statistics for inbound flows are reported via the following
  // name/value pairs.
  //
  //   "flow_id"      : "a.b.c.d:eph -> e.f.g.h:svc",
  //   "pkts"         : xxxxxx,
  //   "bytes"        : xxxxxx,
  //   "rate_bps"     : xxxx.xxx,
  //   "rate_pps"     : xxxx.xxx,
  //   "avg_delay_ms" : xxx.xxx,
  //   "max_delay_ms" : xxx,

  double  rate_bps      = 0.0;
  double  pps           = 0.0;
  double  avg_delay_ms  = 0.0;

  if (now > last_report_time_)
  {
    double  delta_usec = static_cast<double>(
      (now - last_report_time_).GetTimeInUsec());

    rate_bps = static_cast<double>((dump_byte_number_ * 8000000.0) /
                                   delta_usec);
    pps = static_cast<double>((dump_pkt_number_ * 1000000.0) / delta_usec);

    if (dump_pkt_number_ > 0)
    {
      avg_delay_ms  = static_cast<double>(cum_pkt_delay_.GetTimeInMsec());
      avg_delay_ms /= static_cast<double>(dump_pkt_number_);
    }
  }

  string  flow_id_str = (Ipv4Endpoint(four_tuple_.src_addr_nbo(),
                                      four_tuple_.src_port_nbo()).ToString() +
                         " -> " +
                         Ipv4Endpoint(four_tuple_.dst_addr_nbo(),
                                      four_tuple_.dst_port_nbo()).ToString());


  if (udp_proxy_.log_stats())
  {
    log_str.append(
      StringUtils::FormatString(256, "'%s':{", flow_id_str.c_str()));

    log_str.append(
      StringUtils::FormatString(256, "'rcvd_pkts':'%" PRIu32 "', ",
                                total_pkt_number_));

    log_str.append(
      StringUtils::FormatString(256, "'rcvd_bytes':'%" PRIu64 "', ",
                                total_byte_number_));

    log_str.append(
      StringUtils::FormatString(256, "'rcvd_rate_bps':'%f', ", rate_bps));

    log_str.append(
      StringUtils::FormatString(256, "'rcvd_rate_pps':'%f', ", pps));

    log_str.append(
      StringUtils::FormatString(256, "'max_pkt_delay_ms':'%" PRIu64 "', ",
                                max_pkt_delay_.GetTimeInMsec()));

    log_str.append(
      StringUtils::FormatString(256, "'avg_pkt_delay_ms':'%.3f'}",
                                avg_delay_ms));
  }

  if (writer)
  {
    writer->StartObject();

    writer->Key("flow_id");
    writer->String(flow_id_str.c_str());

    writer->Key("pkts");
    writer->Uint64(total_pkt_number_);

    writer->Key("bytes");
    writer->Uint64(total_byte_number_);

    writer->Key("rate_bps");
    writer->Double(rate_bps);

    writer->Key("rate_pps");
    writer->Double(pps);

    writer->Key("max_pkt_delay_ms");
    writer->Uint64(max_pkt_delay_.GetTimeInMsec());

    writer->Key("avg_pkt_delay_ms");
    writer->Double(avg_delay_ms);

    writer->EndObject();
  }

  // Reset the per interval statistics.
  dump_byte_number_ = 0;
  dump_pkt_number_  = 0;
  max_pkt_delay_.Zero();
  cum_pkt_delay_.Zero();
  last_report_time_ = now;
}

//============================================================================
void DecodingState::ReleaseInOrderPackets()
{
  FecState*  fec_state = NULL;

  // Starting with next_grp_id, release as many grps that are ready and in
  // order until there is a group that is not yet ready.
  while (true)
  {
    int   next_fec_grp = GetNextFecGrp(next_grp_id_);
    Time  next_exp     = Time::Infinite();
    if (next_fec_grp != -1)
    {
      next_exp = grp_exp_time(next_fec_grp);
    }

    if(!HasFecState(next_grp_id_))
    {
      fec_grp_ready_time_ = next_exp;
      break;
    }

    GetFecState(next_grp_id_, fec_state);
    fec_state->UpdateFEC();
    LogD(kClassName, __func__, "Releasing sequential packet (group_id %d)\n",
         fec_state->group_id());

    if (SendToReleaseController(fec_state, next_exp))
    {
      DeleteFecState(next_grp_id_);
      ++next_grp_id_;
      LogD(kClassName, __func__, "continue rel\n");
    }
    else  // The next FEC group is not complete, so we wait.
    {
      fec_grp_ready_time_ = fec_state->expiration_time();
      LogD(kClassName, __func__, "Done rel\n");
      break;
    }
  }
}
//============================================================================
int DecodingState::GetNextFecGrp(int cur_group)
{
  if (fec_state_map_.size() == 0)
  {
    return -1;
  }

  // The smallest FEC group ID that is larger than current group ID.
  int next_grp_id = cur_group + FEC_GROUPID_ROLLOVER;

  std::map<int,FecState*>::iterator it;
  for(it = fec_state_map_.begin(); it != fec_state_map_.end(); ++it)
  {
    if (IsLate(it->first, cur_group))
    {
      continue;
    }

    int grp_id = 0;
    if (it->first <= cur_group)
    {
      grp_id = it->first + FEC_GROUPID_ROLLOVER;
    }
    else
    {
      grp_id = it->first;
    }


    //LogD(kClassName, __func__, "has grp %d vs %d\n", it->first,next_grp_id);
    if (grp_id < next_grp_id)
    {
      next_grp_id = grp_id;
    }
  }

  next_grp_id = next_grp_id & FEC_GROUPID_MASK;

  if (next_grp_id == cur_group)
  {
    return -1;
  }
  return next_grp_id;
}

//============================================================================
Time DecodingState::GetNextExpTime(int index, int groupId)
{
  if (fec_state_map_.find(groupId) == fec_state_map_.end())
  {
    return Time::Infinite();
  }

  LogD(kClassName, __func__, "Finding Next exp time for group:%d, pkt %d\n",
       groupId, index);
  Time next_pkt_exp = fec_state_map_[groupId]->next_pkt_exp(index);
  if (next_pkt_exp == Time::Infinite())
  {
    int next_grp = GetNextFecGrp(groupId);
    if (next_grp != -1)
    {
      LogD(kClassName, __func__, "next grp is %d\n", next_grp);
      next_pkt_exp = grp_exp_time(next_grp);
    }
    else
    {
      next_pkt_exp = Time::Infinite();
    }
  }
  return next_pkt_exp;
}

//============================================================================
bool DecodingState::HasFecState(int group_id)
{
  std::map<int,FecState*>::iterator  it;
  it = fec_state_map_.find(group_id);
  return (it != fec_state_map_.end());
}

//============================================================================
void DecodingState::DeleteFecState(int group_id)
{
  std::map<int,FecState*>::iterator  it;
  it = fec_state_map_.find(group_id);
  if (it != fec_state_map_.end())
  {
    LogD(kClassName, __func__, "Deleting %d\n", group_id);
    FecState* fec_state = it->second;
    fec_state->FlushCache();
    fec_state_map_.erase(group_id);
    fecstate_pool_.Recycle(fec_state);
  }
}

//============================================================================
void DecodingState::AccumulatePacketInfo(uint64_t length_bytes,
  const Time& delay)
{
  dump_byte_number_ += length_bytes;
  dump_pkt_number_++;
  total_byte_number_ += length_bytes;
  total_pkt_number_++;
  cum_pkt_delay_     += delay;

  if (delay > max_pkt_delay_)
  {
    max_pkt_delay_  = delay;
  }

  LogD(kClassName, __func__, "fid: %" PRIu32 ", accumulating packet of size %"
       PRIu64 " bytes (total %" PRIu64 ") and delay %s.\n",
       flow_tag_, length_bytes, total_byte_number_,
#ifdef LAT_MEASURE
       delay.ToString().c_str());
#else
       "UNTRACKED");
#endif
}

//============================================================================
void DecodingState::FecGrpReadyTimeout(Time& now)
{
  FecState*  fec_state = NULL;

  while (fec_grp_ready_time_ <= now)
  {
    if (!HasFecState(next_grp_id_))
    {
      if (max_reorder_time_.GetTimeInUsec() > 0)
      {
        LogA(kClassName, __func__, "pktcount: Flow: %zu, Missing FECState "
             "group: %" PRIu32 ".\n", four_tuple_.Hash(), next_grp_id_);
      }
      ++next_grp_id_;
      continue;
    }

    GetFecState(next_grp_id_, fec_state);

    if (fec_state == NULL)
    {
      LogF(kClassName, __func__, "Unable to get FecState for group %d\n",
           next_grp_id_);
    }

    LogD(kClassName, __func__, "Releasing Expired packet (group_id %d)\n",
         fec_state->group_id());

    int   next_fec_grp = GetNextFecGrp(next_grp_id_);
    Time  next_exp = Time::Infinite();
    if (next_fec_grp != -1)
    {
      next_exp = grp_exp_time(next_fec_grp);
    }

    if (SendToReleaseController(fec_state, next_exp))
    {
      DeleteFecState(next_grp_id_);
      ++next_grp_id_;
      fec_grp_ready_time_ = next_exp;
      LogD(kClassName, __func__, "Next exp group is: %d\n", next_grp_id_);
    }
    else
    {
      fec_grp_ready_time_ = fec_state->expiration_time();
      LogD(kClassName, __func__, "Setting exp time to %s, next FEC group "
           "ready time: %s\n",
           fec_state->expiration_time().ToString().c_str(),
           fec_grp_ready_time_.ToString().c_str());
    }
  }

  ReleaseInOrderPackets();
}

//============================================================================
bool DecodingState::SendToReleaseController(FecState* fec_state,
                                            Time& next_exp)
{
  Time     next_pkt_exp  = next_exp;

  // Do repairs, if possible.
  if (fec_state->base_rate() > 0)
  {
    fec_state->UpdateFEC();
  }

  // Send whatever packets we can.
  int   lower_limit = fec_state->getFirstUnsentPktID();
  int   upper_limit = fec_state->max_pkt_id();
  Time  now         = Time::Now();

  LogD(kClassName, __func__, "limits: %d, %d\n", lower_limit, upper_limit);
  if (upper_limit >= 0)
  {
    for (int i = lower_limit; i <= upper_limit; i++)
    {
      // Retrieve and send all valid packets that haven't been sent yet
      // Checking for valid packets that haven't been sent is done in the
      // reassembly code.
      Packet*  rpkt = NULL;
      if ((rpkt = fec_state->ReassembleFromCache(i)) != NULL)
      {
        udp_proxy_.IncrementTotalPktsSent();

        LogD(kClassName, __func__, "SEND: FECState to ReleaseController, "
             "original packet (group_id %d, pktID %d)\n", fec_state->group_id(),
             i);

        if (release_controller_ != NULL)
        {
          release_controller_->HandlePkt(rpkt);
          fec_state->set_pkt_sent(i);
        }
        else
        {
          packet_pool_.Recycle(rpkt);
        }
      }
      else
      {
        // Could not reassemble packet, check if we should skip.
        next_pkt_exp = Time::Min(next_exp, fec_state->next_pkt_exp(i));
        if (next_pkt_exp < now)
        {
          LogA(kClassName, __func__, "pktcount: Missing FECState group: %"
               PRIu32 " slot: %" PRIu32 " \n.", fec_state->group_id(), i);
          fec_state->set_pkt_sent(i);
        }
        else
        {
          // We still have time, wait until the next packet expires.
          break;
        }
      }
    }
  }

  // Check if there is still packets to send in this state.
  if (fec_state->fec_used() && next_pkt_exp > now)
  {
    if (fec_state->getFirstUnsentPktID() < fec_state->base_rate() ||
        fec_state->base_rate() == 0)
    {
      // We haven't received all the original packets or a repair pkt.
      fec_state->set_expiration_time(next_pkt_exp);
      return false;
    }
  }

  // Only do error recording and RRMs if there is reordering.
  if (max_reorder_time_.GetTimeInUsec() > 0)
  {
    // Advance the counter of bytes/packets sourced to this FEC group.
    UdpProxy::ReleaseRecord*  release_record  = NULL;
    udp_proxy_.GetReleaseRecord(bin_idx_, four_tuple_, release_record);

    if (release_record != NULL)
    {
      double  curr_loss_rate = release_record->ReleaseFecState(*fec_state);

      // Send an RRM to the source if the loss rate cross the threshold.
      if ((curr_loss_rate * 100 > loss_thresh_pct_) &&
          (now - release_record->last_rrm_sent_) >
          Time::FromMsec(kMinEventRrmIntervalMsec))
      {
        LogD(kClassName, __func__, "RRM triggered by flow %s.\n",
             fec_state->decoding_state()->four_tuple().ToString().c_str());
        udp_proxy_.SendRRMs(now);
        release_record->last_rrm_sent_ = now;
      }
    }
    else
    {
      LogE(kClassName, __func__, "Release record not found for %u\n",
           four_tuple_.ToString().c_str());
    }
  }

  return true;
}
