// IRON: iron_headers
/*
 * Distribution A
 *
 * Approved for Public Release, Distribution Unlimited
 *
 * EdgeCT (IRON) Software Contract No.: HR0011-15-C-0097
 * DCOMP (GNAT)  Software Contract No.: HR0011-17-C-0050
 * Copyright (c) 2015-20 Raytheon BBN Technologies Corp.
 *
 * This material is based upon work supported by the Defense Advanced
 * Research Projects Agency under Contracts No. HR0011-15-C-0097 and
 * HR0011-17-C-0050. Any opinions, findings and conclusions or
 * recommendations expressed in this material are those of the author(s)
 * and do not necessarily reflect the views of the Defense Advanced
 * Research Project Agency.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/* IRON: end */

#ifndef IRON_SLIQ_CAPACITY_ESTIMATOR_H
#define IRON_SLIQ_CAPACITY_ESTIMATOR_H

#include "sliq_app.h"
#include "sliq_private_types.h"
#include "sliq_types.h"

#include "itime.h"

#include <cstdlib>


namespace sliq
{

  /// \brief A class that estimates the capacity of a connection to a peer.
  ///
  /// This class is designed to track the capacity estimates for all of the
  /// congestion control algorithms in use by a single connection and
  /// consolidate them into a single connection capacity estimate.  At
  /// startup, the Initialize() method must be called with the connection's
  /// endpoint identifier, and each congestion control algorithm must be
  /// initialized by calling the InitCcAlg() method with the algorithm's
  /// congestion window information.  This information includes if the
  /// congestion window size should be used for estimating the capacity, and
  /// if so, what the initial congestion window size is in bytes.  If the
  /// congestion window size should not be used, then a congestion control
  /// send rate estimate, as used for transmit pacing, must be used instead.
  ///
  /// Once initialized, the UpdateCapacityEstimate() method is called whenever
  /// one of the congestion control algorithms receives an ACK of a data
  /// packet that it allowed to be sent.  The return value from this method
  /// indicates if the aggregated capacity estimate should be reported back to
  /// the application or not.
  ///
  /// Capacity estimates are generated by observing the sizes of data packets
  /// that are ACKed during a collection interval.  The collection interval
  /// duration is set to a constant time of 1 second.  During each interval,
  /// two sizes are collected.  The first is the total number of bytes sent on
  /// the channel that are ACKed (chan_acked_bytes).  The second is the total
  /// number of transport payload bytes sent on the channel that are ACKed
  /// (trans_acked_bytes).
  ///
  /// At the end of a collection interval, the capacity estimates for each
  /// congestion control algorithm are updated as follows.  First, the average
  /// channel and transport peer receive rates are computed for the algorithm:
  /// \verbatim
  ///   chan_recv_rate  = ((chan_acked_bytes * 8) / collection_interval)  (1)
  ///   trans_recv_rate = ((trans_acked_bytes * 8) / collection_interval) (2)
  /// \endverbatim
  /// These peer receive rates are also aggregated for all algorithms into
  /// total channel and transport peer receive rates (total_chan_recv_rate and
  /// total_trans_recv_rate).
  ///
  /// If the congestion window size is being used for estimating the capacity,
  /// then the last reported congestion window size for the algorithm in the
  /// current collection interval is compared with the last reported
  /// congestion window size for the algorithm at the end of the previous
  /// collection interval.  If they are different by more than the largest
  /// packet size (1472 bytes), then the peer receive rate is close to the
  /// channel capacity and the peer receive rates computed above are saved as
  /// a capacity estimate candidate.  Otherwise, if the total channel peer
  /// receive rate is greater than the most recent capacity estimate
  /// candidate's total channel peer receive rate, then the peer receive rates
  /// computed above are written into the most recent capacity estimate
  /// candidate.  The two most recent capacity estimate candidates are stored
  /// at all times for the algorithm.
  ///
  /// If the congestion window size is not being used for estimating the
  /// capacity, then the last reported rate estimate rate_est for the
  /// algorithm in the current collection interval is compared with the
  /// channel peer receive rate chan_recv_rate computed in (1) above in the
  /// current collection interval.  If rate_est is close enough to
  /// chan_recv_rate (within 90% to 110% of chan_recv_rate), then the peer
  /// receive rate is close to the channel capacity and the peer receive rates
  /// computed above are saved as a capacity estimate candidate.  Otherwise,
  /// if the total channel peer receive rate is greater than the capacity
  /// estimate candidate's total channel peer receive rate, then the peer
  /// receive rates computed above are written into the capacity estimate
  /// candidate.  Only one capacity estimate candidate is stored for the
  /// algorithm.
  ///
  /// The current connection capacity estimates at the end of each collection
  /// interval are the total peer receive rates (total_chan_recv_rate and
  /// total_trans_recv_rate) that contain the maximum total_chan_recv_rate
  /// value in all of the updated capacity estimate candidates.
  ///
  /// If the current connection channel capacity estimate has changed enough
  /// since the last application report (either it has increased by any
  /// amount, or it has decreased by at least 10%) or enough time has passed
  /// since the last application report (4 seconds), then the current
  /// connection channel and transport capacity estimates should be reported
  /// to the application.  The next collection interval then starts.
  ///
  /// If the connection enters an outage at any time, then the connection
  /// channel and transport capacity estimates are both set to zero
  /// immediately.  If the outage has just been entered, then the zero
  /// capacity estimates should be reported to the application immediately.
  /// Afterward, the zero capacity estimates must be reported to the
  /// application periodically (every 4 seconds).  When the outage is over, a
  /// new collection interval is started and processing follows the normal
  /// update rules above.
  class CapacityEstimator
  {

   public:

    /// Constructor.
    CapacityEstimator();

    /// Destructor.
    virtual ~CapacityEstimator();

    /// \brief Initialize the capacity estimator.
    ///
    /// \param  conn_id  The connection identifier.
    void Initialize(EndptId conn_id);

    /// \brief Initialize a congestion control algorithm to be included in the
    /// capacity estimates.
    ///
    /// If use_cwnd is true, then the congestion window size will be used to
    /// compute the capacity estimate in UpdateCapacityEstimate().  If
    /// use_cwnd is false, then the congestion control rate estimate will be
    /// used in UpdateCapacityEstimate() instead.
    ///
    /// \param  cc_id     The congestion control identifier.
    /// \param  use_cwnd  A flag indicating if the congestion window size
    ///                   should be used for creating the capacity estimate or
    ///                   not.
    /// \param  cwnd      The initial congestion window size, in bytes.  Only
    ///                   used if use_cwnd is true.
    ///
    /// \return  True if the congestion control algorithm is initialized
    ///          successfully, or false if not.
    bool InitCcAlg(CcId cc_id, bool use_cwnd, size_t cwnd);

    /// \brief Update the capacity estimates.
    ///
    /// This is called each time that one of the congestion control algorithms
    /// receives an ACK for a packet.
    ///
    /// \param  cc_id              The congestion control identifier of the
    ///                            algorithm that received the ACK.
    /// \param  now                The current time.
    /// \param  app_payload_bytes  The number of application payload bytes in
    ///                            the packet.
    /// \param  bytes_sent         The size of the SLIQ headers and payload
    ///                            sent, in bytes.
    /// \param  cwnd               The current congestion window size, in
    ///                            bytes.  Only used if the congestion control
    ///                            algorithm was configured with use_cwnd set
    ///                            to true.
    /// \param  rate_est_bps       The current congestion control send rate
    ///                            estimate, in bits per second.  Only used if
    ///                            the congestion control algorithm was
    ///                            configured with use_cwnd set to false.
    /// \param  in_outage          The current outage state.
    /// \param  chan_ce_bps        The resulting channel capacity estimate, in
    ///                            bps.  Only set if the method returns true.
    /// \param  trans_ce_bps       The resulting transport capacity estimate,
    ///                            in bps.  Only set if the method returns
    ///                            true.
    /// \param  ccl_time_sec       The amount of time, in seconds, since a
    ///                            congestion control limit event caused a
    ///                            capacity estimate update.  Only set if the
    ///                            method returns true.
    ///
    /// \return  True if the capacity estimates should be reported back to the
    ///          SliqApp, or false if not.
    bool UpdateCapacityEstimate(CcId cc_id, const iron::Time& now,
                                size_t app_payload_bytes, size_t bytes_sent,
                                size_t cwnd, double rate_est_bps,
                                bool in_outage, double& chan_ce_bps,
                                double& trans_ce_bps, double& ccl_time_sec);

   private:

    /// The size of the rate history that is stored for each algorithm.
    static const size_t  kRateHistorySize = 2;

    /// \brief Structure for a single rate history entry for a single
    /// congestion control algorithm.
    struct CwndRate
    {
      CwndRate();
      virtual ~CwndRate();

      /// The congestion window size for the rates in bytes.
      size_t  cwnd_size_;

      /// The computed channel peer receive rate in bits per second.
      double  chan_rate_;

      /// The computed transport peer receive rate in bits per second.
      double  trans_rate_;

      /// The total computed channel peer receive rate in bits per second.
      double  total_chan_rate_;

      /// The total computed transport peer receive rate in bits per second.
      double  total_trans_rate_;
    };

    /// \brief Structure for a storing capacity estimate state for a single
    /// congestion control algorithm.
    struct CcState
    {
      CcState();
      virtual ~CcState();

      /// The flag recording if the algorithm has been initialized.
      bool        init_;

      /// The flag recording if the congestion window size should be used when
      /// generating the capacity estimates for this algorithm.
      bool        use_cwnd_;

      /// The size of the congestion window, in bytes, at the end of the
      /// previous collection interval for this algorithm.
      size_t      start_cc_cwnd_;

      /// The size of the congestion window, in bytes, at the end of the
      /// collection interval for this algorithm.
      size_t      end_cc_cwnd_;

      /// The congestion control rate estimate, in bits per second, at the end
      /// of the collection interval for this algorithm.
      double      end_cc_rate_;

      /// The last time the congestion control limit was hit for this
      /// algorithm.
      iron::Time  last_cc_limit_time_;

      /// The total number of bytes sent samples for this algorithm during the
      /// collection interval.
      size_t      num_samples_;

      /// The total number of bytes acked by the channel by this algorithm
      /// during the collection interval.
      size_t      chan_acked_bytes_;

      /// The total number of transport bytes acked by this algorithm during
      /// the collection interval.
      size_t      trans_acked_bytes_;

      /// The current raw channel receive rate by the peer for this algorithm
      /// in bits per second.
      double      chan_recv_rate_;

      /// The current raw transport receive rate by the peer for this
      /// algorithm in bits per second.
      double      trans_recv_rate_;

      /// The total channel capacity estimate for all algorithms, according to
      /// this algorithm, in bits per second.
      double      chan_cap_est_;

      /// The total transport capacity estimate for all algorithms, according
      /// to this algorithm, in bits per second.
      double      trans_cap_est_;

      /// The most recent rate estimates.
      CwndRate    rate_[kRateHistorySize];
    };

    /// \brief Copy constructor.
    CapacityEstimator(const CapacityEstimator& ce);

    /// \brief Assignment operator.
    CapacityEstimator& operator=(const CapacityEstimator& ce);

    /// The connection identifier.
    EndptId     conn_id_;

    /// The flag recording if the connection is currently in an outage.
    bool        is_in_outage_;

    /// The start time for a collection interval.
    iron::Time  start_time_;

    /// The collection interval duration.
    iron::Time  collection_interval_;

    /// The next capacity estimate report time.
    iron::Time  next_report_time_;

    /// The channel capacity estimate in bits per second.
    double      chan_cap_est_;

    /// The transport capacity estimate in bits per second.
    double      trans_cap_est_;

    /// The last channel capacity estimate reported in bits per second.
    double      last_chan_cap_est_;

    /// The last transport capacity estimate reported in bits per second.
    double      last_trans_cap_est_;

    /// The state for each congestion control algorithm.
    CcState     cc_state_[SliqApp::kMaxCcAlgPerConn];

  }; // end class CapacityEstimator

} // namespace sliq

#endif// IRON_SLIQ_CAPACITY_ESTIMATOR_H
