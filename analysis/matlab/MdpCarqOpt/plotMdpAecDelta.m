clc; clear;

% Load data generated by mdpopt
mdpsol = importdata('mdpcarqresults.txt',' ');

% Determine the best value of K for each nRounds, epsilon, per operating pt 
kvals = mdpsol(:,1);
klen  = length(kvals);
kMin  = mdpsol(1,1);
kMax  = mdpsol(klen,1);
nBlks = kMax - kMin + 1;
blkSz = klen / nBlks;

bestmdp = mdpsol(1:blkSz,:);
for i=kMin+1:kMax
    test = mdpsol((i-kMin)*blkSz+1:(i-kMin+1)*blkSz,:);
    for j=1:blkSz
        if (test(j,6) > bestmdp(j,6))
            bestmdp(j,:) = test(j,:);
        end
    end
end

% Load data generated by aecsim
aecsol = importdata('aeccarqresults.txt',' ');

% Determine the best value of K for each nRounds, epsilon, per operating pt 
kvals = aecsol(:,1);
klen  = length(kvals);
kMin  = aecsol(1,1);
kMax  = aecsol(klen,1);
nBlks = kMax - kMin + 1;
blkSz = klen / nBlks;

bestaec = aecsol(1:blkSz,:);
for i=kMin+1:kMax
    test = aecsol((i-kMin)*blkSz+1:(i-kMin+1)*blkSz,:);
    for j=1:blkSz
        if (test(j,6) > bestaec(j,6))
            bestaec(j,:) = test(j,:);
        end
    end
end

delta=max((bestmdp(:,6)-bestaec(:,6)),0);

kvals = bestaec(:,1);
z     = bestaec(:,2); %% per
x     = bestaec(:,3); %% rounds
y     = bestaec(:,4); %% epsilon
sz    = delta;        %% difference in efficiency

% The following should be true and retrievable from the file
% epsilon = 0.005:0.005:0.05;
% rounds = 0:10;
% loss_rate = 0.1:0.1:0.5;

loss_rate = unique(z);
nLosses   = length(loss_rate);

rounds  = unique(x);
nRounds = length(rounds);

epsilon = unique(y);
nEps    = length(epsilon);

% Do a sanity check on the block size
if (nLosses * nRounds * nEps ~= blkSz)
    fprintf('Data sizes do not match. Exiting\n');
    return;
end

% Use a circle for FEC and Coded ARQ; square for ARQ
%shapes = ['o', 's'];

% Use a circles for everything
shapes = ['o', 'o'];

% Use red for Coded ARQ, blue for ARQ and green for FEC
% colors = ['r', 'g', 'b'];
colors = [[1, 0, 0]; [0, 0.65, 0]; [0, 0, 1]];

for i=1:blkSz
    % FEC
    if (x(i) == 1)
        color(i) = 2;
        shape(i) = 1;
    end
    % Coded ARQ or ARQ
    if (x(i) >= 2)
        color(i) = 1;
        shape(i) = 1;
    end
    % ARQ
    per = z(i);
    rnd = x(i);
    eps = y(i);
    if (per^rnd < eps)
        color(i) = 3;
        shape(i) = 2;
    end
end

% Normalize dot diameter so it's between sz_min and sz_max
e_min = min(sz);
e_max = max(sz);
sz_min = 10;
sz_max = 50;
sz = (sz-e_min)*(sz_max-sz_min)/(e_max-e_min)+sz_min;

s = scatter3(0,0,0,0.1);
axis([-0.2 10.2 0 max(epsilon)+.001 0 0.52]);
hold on;
% scatter3 cannot take color and shape vectors, so loop over the
% combinations and update one at a time
for sh = 1:2
    for c = 1:3
        idx = find(shape==sh &color==c);
        scatter3(x(idx),y(idx),z(idx),sz(idx), colors(c,:), ...
            shapes(sh),'filled');
    end
end
xlabel('Rounds', 'FontSize', 26);
ylabel('Epsilon','FontSize', 26);
zlabel('Loss Rate','FontSize', 26);
xlim([1,6]);
zlim([0,0.5]);

xticks(rounds);
yticks(epsilon);
zticks(loss_rate);
ax = ancestor(s, 'axes');
xrule = ax.XAxis;
yrule = ax.YAxis;
zrule = ax.ZAxis;
xrule.FontSize = 8;
yrule.FontSize = 8;
zrule.FontSize = 8;
yrule.TickLabelRotation = 45;
ax.FontWeight = 'bold';
%grid('off');
set(gcf,'color','w')
rotate3d on;
xlim([1,6]);
view(-48.6,5.9);
